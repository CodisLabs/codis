From 7e358591b490e8ca84c7bbd810077f98609025e2 Mon Sep 17 00:00:00 2001
From: justfly <justfly.py@gmail.com>
Date: Tue, 8 Aug 2017 16:55:11 +0800
Subject: [PATCH] merge codis's patch to redis/4.0.1

---
 src/Makefile      |    4 +-
 src/crc32.c       |   41 ++
 src/db.c          |   48 +-
 src/help.h        |  121 +++-
 src/lazyfree.c    |   11 +
 src/networking.c  |    8 +
 src/server.c      |   86 ++-
 src/server.h      |   72 +++
 src/slots.c       |  884 ++++++++++++++++++++++++++
 src/slots_async.c | 1769 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/t_hash.c      |    8 +
 11 files changed, 3043 insertions(+), 9 deletions(-)
 create mode 100644 src/crc32.c
 create mode 100644 src/slots.c
 create mode 100644 src/slots_async.c

diff --git a/extern/redis-4.0.1/src/Makefile b/extern/redis-4.0.1/src/Makefile
index 86e0b3fe..336dee4b 100644
--- a/extern/redis-4.0.1/src/Makefile
+++ b/extern/redis-4.0.1/src/Makefile
@@ -122,7 +122,7 @@ endif
 ifeq ($(MALLOC),jemalloc)
 	DEPENDENCY_TARGETS+= jemalloc
 	FINAL_CFLAGS+= -DUSE_JEMALLOC -I../deps/jemalloc/include
-	FINAL_LIBS+= ../deps/jemalloc/lib/libjemalloc.a
+	FINAL_LIBS+= ../deps/jemalloc/lib/libjemalloc.a -lrt
 endif
 
 REDIS_CC=$(QUIET_CC)$(CC) $(FINAL_CFLAGS)
@@ -144,7 +144,7 @@ endif
 
 REDIS_SERVER_NAME=redis-server
 REDIS_SENTINEL_NAME=redis-sentinel
-REDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o
+REDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o slots.o slots_async.o crc32.o
 REDIS_CLI_NAME=redis-cli
 REDIS_CLI_OBJ=anet.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o
 REDIS_BENCHMARK_NAME=redis-benchmark
diff --git a/extern/redis-4.0.1/src/crc32.c b/extern/redis-4.0.1/src/crc32.c
new file mode 100644
index 00000000..cc7ae861
--- /dev/null
+++ b/extern/redis-4.0.1/src/crc32.c
@@ -0,0 +1,41 @@
+#include <stdint.h>
+
+static const uint32_t IEEE_POLY = 0xedb88320;
+
+static uint32_t crc32tab[256];
+
+static void
+crc32_tabinit(uint32_t poly) {
+    int i, j;
+    for (i = 0; i < 256; i ++) {
+        uint32_t crc = i;
+        for (j = 0; j < 8; j ++) {
+            if (crc & 1) {
+                crc = (crc >> 1) ^ poly;
+            } else {
+                crc = (crc >> 1);
+            }
+        }
+        crc32tab[i] = crc;
+    }
+}
+
+void
+crc32_init() {
+    crc32_tabinit(IEEE_POLY);
+}
+
+static uint32_t
+crc32_update(uint32_t crc, const char *buf, int len) {
+    int i;
+    crc = ~crc;
+    for (i = 0; i < len; i ++) {
+        crc = crc32tab[(uint8_t)((char)crc ^ buf[i])] ^ (crc >> 8);
+    }
+    return ~crc;
+}
+
+uint32_t
+crc32_checksum(const char *buf, int len) {
+    return crc32_update(0, buf, len);
+}
diff --git a/extern/redis-4.0.1/src/db.c b/extern/redis-4.0.1/src/db.c
index 7d1504d3..2beef2fc 100644
--- a/extern/redis-4.0.1/src/db.c
+++ b/extern/redis-4.0.1/src/db.c
@@ -161,6 +161,16 @@ void dbAdd(redisDb *db, robj *key, robj *val) {
     sds copy = sdsdup(key->ptr);
     int retval = dictAdd(db->dict, copy, val);
 
+    do {
+        uint32_t crc;
+        int hastag;
+        int slot = slots_num(key->ptr, &crc, &hastag);
+        dictAdd(db->hash_slots[slot], copy, (void *)(long)crc);
+        if (hastag) {
+            zslInsert(db->tagged_keys, (double)crc, sdsdup(key->ptr));
+        }
+    } while (0);
+
     serverAssertWithInfo(NULL,key,retval == DICT_OK);
     if (val->type == OBJ_LIST) signalListAsReady(db, key);
     if (server.cluster_enabled) slotToKeyAdd(key);
@@ -239,6 +249,18 @@ int dbSyncDelete(redisDb *db, robj *key) {
     /* Deleting an entry from the expires dict will not free the sds of
      * the key, because it is shared with the main dictionary. */
     if (dictSize(db->expires) > 0) dictDelete(db->expires,key->ptr);
+
+    do {
+        uint32_t crc;
+        int hastag;
+        int slot = slots_num(key->ptr, &crc, &hastag);
+        if (dictDelete(db->hash_slots[slot], key->ptr) == DICT_OK) {
+            if (hastag) {
+                zslDelete(db->tagged_keys, (double)crc, key->ptr, NULL);
+            }
+        }
+    } while (0);
+
     if (dictDelete(db->dict,key->ptr) == DICT_OK) {
         if (server.cluster_enabled) slotToKeyDel(key);
         return 1;
@@ -307,6 +329,7 @@ robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) {
  * database(s). Otherwise -1 is returned in the specific case the
  * DB number is out of range, and errno is set to EINVAL. */
 long long emptyDb(int dbnum, int flags, void(callback)(void*)) {
+    int i;
     int j, async = (flags & EMPTYDB_ASYNC);
     long long removed = 0;
 
@@ -318,6 +341,13 @@ long long emptyDb(int dbnum, int flags, void(callback)(void*)) {
     for (j = 0; j < server.dbnum; j++) {
         if (dbnum != -1 && dbnum != j) continue;
         removed += dictSize(server.db[j].dict);
+        for (i = 0; i < HASH_SLOTS_SIZE; i ++) {
+            dictEmpty(server.db[j].hash_slots[i], NULL);
+        }
+        if (server.db[j].tagged_keys->length != 0) {
+            zslFree(server.db[j].tagged_keys);
+            server.db[j].tagged_keys = zslCreate();
+        }
         if (async) {
             emptyDbAsync(&server.db[j]);
         } else {
@@ -390,10 +420,18 @@ int getFlushCommandFlags(client *c, int *flags) {
  *
  * Flushes the currently SELECTed Redis DB. */
 void flushdbCommand(client *c) {
+    int i;
     int flags;
 
     if (getFlushCommandFlags(c,&flags) == C_ERR) return;
     signalFlushedDb(c->db->id);
+    for (i = 0; i < HASH_SLOTS_SIZE; i ++) {
+        dictEmpty(c->db->hash_slots[i], NULL);
+    }
+    if (c->db->tagged_keys->length != 0) {
+        zslFree(c->db->tagged_keys);
+        c->db->tagged_keys = zslCreate();
+    }
     server.dirty += emptyDb(c->db->id,flags,NULL);
     addReply(c,shared.ok);
 }
@@ -820,7 +858,15 @@ void shutdownCommand(client *c) {
      * Also when in Sentinel mode clear the SAVE flag and force NOSAVE. */
     if (server.loading || server.sentinel_mode)
         flags = (flags & ~SHUTDOWN_SAVE) | SHUTDOWN_NOSAVE;
-    if (prepareForShutdown(flags) == C_OK) exit(0);
+    if (prepareForShutdown(flags) == C_OK) {
+        for (int j = 0; j < server.dbnum; j ++) {
+            for (int i = 0; i < HASH_SLOTS_SIZE; i ++) {
+                dictRelease(server.db[j].hash_slots[i]);
+            }
+            zslFree(server.db[j].tagged_keys);
+        }
+        exit(0);
+    }
     addReplyError(c,"Errors trying to SHUTDOWN. Check logs.");
 }
 
diff --git a/extern/redis-4.0.1/src/help.h b/extern/redis-4.0.1/src/help.h
index 5f927c30..057cbcbf 100644
--- a/extern/redis-4.0.1/src/help.h
+++ b/extern/redis-4.0.1/src/help.h
@@ -17,7 +17,8 @@ static char *commandGroups[] = {
     "scripting",
     "hyperloglog",
     "cluster",
-    "geo"
+    "geo",
+    "codis",
 };
 
 struct commandHelp {
@@ -1011,7 +1012,123 @@ struct commandHelp {
     "destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]",
     "Add multiple sorted sets and store the resulting sorted set in a new key",
     4,
-    "2.0.0" }
+    "2.0.0" },
+    {"SLOTSINFO",
+        "-",
+        "", 14, "codis1.9"
+    },
+    {"SLOTSSCAN",
+        "slotnum cursor [COUNT count]",
+        "", 14, "codis3.1"
+    },
+    {"SLOTSDEL",
+        "slot [slot ...]",
+        "", 14, "codis1.9"
+    },
+    {"SLOTSMGRTSLOT",
+        "host port timeout slot",
+        "", 14, "codis1.9"
+    },
+    {"SLOTSMGRTTAGSLOT",
+        "host port timeout slot",
+        "", 14, "codis1.9"
+    },
+    {"SLOTSMGRTONE",
+        "host port timeout key",
+        "", 14, "codis1.9"
+    },
+    {"SLOTSMGRTTAGONE",
+        "host port timeout key",
+        "", 14, "codis1.9"
+    },
+    {"SLOTSHASHKEY",
+        "key [key...]",
+        "", 14, "codis1.9"
+    },
+    {"SLOTSCHECK",
+        "-",
+        "", 14, "codis1.9"
+    },
+    {"SLOTSRESTORE",
+        "key ttl val [key ttl val ...]",
+        "", 14, "codis1.9"
+    },
+    {"SLOTSMGRTSLOT-ASYNC",
+        "host port timeout maxbulks maxbytes slot numkeys",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSMGRTTAGSLOT-ASYNC",
+        "host port timeout maxbulks maxbytes slot numkeys",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSMGRTONE-ASYNC",
+        "host port timeout maxbulks maxbytes key [key...]",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSMGRTTAGONE-ASYNC",
+        "host port timeout maxbulks maxbytes key [key...]",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSMGRTONE-ASYNC-DUMP",
+        "timeout maxbulks key [key...]",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSMGRTTAGONE-ASYNC-DUMP",
+        "timeout maxbulks key [key...]",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSMGRT-ASYNC-FENCE",
+        "-",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSMGRT-ASYNC-CANCEL",
+        "-",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSMGRT-ASYNC-STATUS",
+        "-",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSMGRT-EXEC-WRAPPER",
+        "hashkey command [arg ...]",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSRESTORE-ASYNC-SELECT",
+        "db",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSRESTORE-ASYNC DELETE",
+        "key",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSRESTORE-ASYNC EXPIRE",
+        "key ttl",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSRESTORE-ASYNC OBJECT",
+        "key ttl payload",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSRESTORE-ASYNC LIST",
+        "key ttl hint [elem ...]",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSRESTORE-ASYNC HASH",
+        "key ttl hint [field value ...]",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSRESTORE-ASYNC DICT",
+        "key ttl hint [elem ...]",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSRESTORE-ASYNC ZSET",
+        "key ttl hint [field score ...]",
+        "", 14, "codis3.2"
+    },
+    {"SLOTSRESTORE-ASYNC-AUTH",
+        "passwd",
+        "", 14, "codis3.2"
+    }
 };
 
 #endif
diff --git a/extern/redis-4.0.1/src/lazyfree.c b/extern/redis-4.0.1/src/lazyfree.c
index 809ebdb5..d7a9bf2c 100644
--- a/extern/redis-4.0.1/src/lazyfree.c
+++ b/extern/redis-4.0.1/src/lazyfree.c
@@ -56,6 +56,17 @@ int dbAsyncDelete(redisDb *db, robj *key) {
      * the key, because it is shared with the main dictionary. */
     if (dictSize(db->expires) > 0) dictDelete(db->expires,key->ptr);
 
+    do {
+        uint32_t crc;
+        int hastag;
+        int slot = slots_num(key->ptr, &crc, &hastag);
+        if (dictDelete(db->hash_slots[slot], key->ptr) == DICT_OK) {
+            if (hastag) {
+                zslDelete(db->tagged_keys, (double)crc, key->ptr, NULL);
+            }
+        }
+    } while (0);
+
     /* If the value is composed of a few allocations, to free in a lazy way
      * is actually just slower... So under a certain limit we just free
      * the object synchronously. */
diff --git a/extern/redis-4.0.1/src/networking.c b/extern/redis-4.0.1/src/networking.c
index aeaeca96..df080116 100644
--- a/extern/redis-4.0.1/src/networking.c
+++ b/extern/redis-4.0.1/src/networking.c
@@ -133,6 +133,8 @@ client *createClient(int fd) {
     c->pubsub_channels = dictCreate(&objectKeyPointerValueDictType,NULL);
     c->pubsub_patterns = listCreate();
     c->peerid = NULL;
+    c->slotsmgrt_flags = 0;
+    c->slotsmgrt_fenceq = NULL;
     listSetFreeMethod(c->pubsub_patterns,decrRefCountVoid);
     listSetMatchMethod(c->pubsub_patterns,listMatchObjects);
     if (fd != -1) listAddNodeTail(server.clients,c);
@@ -798,6 +800,8 @@ void freeClient(client *c) {
             replicationGetSlaveName(c));
     }
 
+    slotsmgrtAsyncUnlinkClient(c);
+
     /* Free the query buffer */
     sdsfree(c->querybuf);
     sdsfree(c->pending_querybuf);
@@ -1863,6 +1867,10 @@ int checkClientOutputBufferLimits(client *c) {
     int soft = 0, hard = 0, class;
     unsigned long used_mem = getClientOutputBufferMemoryUsage(c);
 
+    if (c->slotsmgrt_flags & CLIENT_SLOTSMGRT_ASYNC_CACHED_CLIENT) {
+        return 0;
+    }
+
     class = getClientType(c);
     /* For the purpose of output buffer limiting, masters are handled
      * like normal clients. */
diff --git a/extern/redis-4.0.1/src/server.c b/extern/redis-4.0.1/src/server.c
index 2da6fb54..9c556d33 100644
--- a/extern/redis-4.0.1/src/server.c
+++ b/extern/redis-4.0.1/src/server.c
@@ -304,7 +304,31 @@ struct redisCommand redisCommandTable[] = {
     {"pfdebug",pfdebugCommand,-3,"w",0,NULL,0,0,0,0,0},
     {"post",securityWarningCommand,-1,"lt",0,NULL,0,0,0,0,0},
     {"host:",securityWarningCommand,-1,"lt",0,NULL,0,0,0,0,0},
-    {"latency",latencyCommand,-2,"aslt",0,NULL,0,0,0,0,0}
+    {"latency",latencyCommand,-2,"aslt",0,NULL,0,0,0,0,0},
+    {"slotsinfo",slotsinfoCommand,-1,"rF",0,NULL,0,0,0,0,0},
+    {"slotsscan",slotsscanCommand,-3,"rR",0,NULL,0,0,0,0,0},
+    {"slotsdel",slotsdelCommand,-2,"w",0,NULL,1,-1,1,0,0},
+    {"slotsmgrtslot",slotsmgrtslotCommand,5,"w",0,NULL,0,0,0,0,0},
+    {"slotsmgrttagslot",slotsmgrttagslotCommand,5,"w",0,NULL,0,0,0,0,0},
+    {"slotsmgrtone",slotsmgrtoneCommand,5,"w",0,NULL,0,0,0,0,0},
+    {"slotsmgrttagone",slotsmgrttagoneCommand,5,"w",0,NULL,0,0,0,0,0},
+    {"slotshashkey",slotshashkeyCommand,-1,"rF",0,NULL,0,0,0,0,0},
+    {"slotscheck",slotscheckCommand,0,"r",0,NULL,0,0,0,0,0},
+    {"slotsrestore",slotsrestoreCommand,-4,"wm",0,NULL,0,0,0,0,0},
+    {"slotsmgrtslot-async",slotsmgrtSlotAsyncCommand,8,"ws",0,NULL,0,0,0,0,0},
+    {"slotsmgrttagslot-async",slotsmgrtTagSlotAsyncCommand,8,"ws",0,NULL,0,0,0,0,0},
+    {"slotsmgrtone-async",slotsmgrtOneAsyncCommand,-7,"ws",0,NULL,0,0,0,0,0},
+    {"slotsmgrttagone-async",slotsmgrtTagOneAsyncCommand,-7,"ws",0,NULL,0,0,0,0,0},
+    {"slotsmgrtone-async-dump",slotsmgrtOneAsyncDumpCommand,-4,"rm",0,NULL,0,0,0,0,0},
+    {"slotsmgrttagone-async-dump",slotsmgrtTagOneAsyncDumpCommand,-4,"rm",0,NULL,0,0,0,0,0},
+    {"slotsmgrt-async-fence",slotsmgrtAsyncFenceCommand,0,"rs",0,NULL,0,0,0,0,0},
+    {"slotsmgrt-async-cancel",slotsmgrtAsyncCancelCommand,0,"F",0,NULL,0,0,0,0,0},
+    {"slotsmgrt-async-status",slotsmgrtAsyncStatusCommand,0,"F",0,NULL,0,0,0,0,0},
+    {"slotsmgrt-exec-wrapper",slotsmgrtExecWrapperCommand,-3,"wm",0,NULL,0,0,0,0,0},
+    {"slotsrestore-async",slotsrestoreAsyncCommand,-2,"wm",0,NULL,0,0,0,0,0},
+    {"slotsrestore-async-auth",slotsrestoreAsyncAuthCommand,2,"sltF",0,NULL,0,0,0,0,0},
+    {"slotsrestore-async-select",slotsrestoreAsyncSelectCommand,2,"lF",0,NULL,0,0,0,0,0},
+    {"slotsrestore-async-ack",slotsrestoreAsyncAckCommand,3,"w",0,NULL,0,0,0,0,0},
 };
 
 /*============================ Utility functions ============================ */
@@ -581,6 +605,15 @@ dictType dbDictType = {
     dictObjectDestructor   /* val destructor */
 };
 
+dictType hashSlotType = {
+    dictSdsHash,                /* hash function */
+    NULL,                       /* key dup */
+    NULL,                       /* val dup */
+    dictSdsKeyCompare,          /* key compare */
+    NULL,                       /* key destructor */
+    NULL                        /* val destructor */
+};
+
 /* server.lua_scripts sha (as sds string) -> scripts (as robj) cache. */
 dictType shaScriptObjectDictType = {
     dictSdsCaseHash,            /* hash function */
@@ -702,8 +735,15 @@ int htNeedsResize(dict *dict) {
 /* If the percentage of used slots in the HT reaches HASHTABLE_MIN_FILL
  * we resize the hash table to save memory */
 void tryResizeHashTables(int dbid) {
-    if (htNeedsResize(server.db[dbid].dict))
+    if (htNeedsResize(server.db[dbid].dict)) {
         dictResize(server.db[dbid].dict);
+        for (int i = 0; i < HASH_SLOTS_SIZE; i ++) {
+            dict *d = server.db[dbid].hash_slots[i];
+            if (htNeedsResize(d)) {
+                dictResize(d);
+            }
+        }
+    }
     if (htNeedsResize(server.db[dbid].expires))
         dictResize(server.db[dbid].expires);
 }
@@ -719,6 +759,22 @@ int incrementallyRehash(int dbid) {
     /* Keys dictionary */
     if (dictIsRehashing(server.db[dbid].dict)) {
         dictRehashMilliseconds(server.db[dbid].dict,1);
+        server.db[dbid].hash_slots_rehashing = 1;
+        return 1; /* already used our millisecond for this loop... */
+    }
+    if (server.db[dbid].hash_slots_rehashing) {
+        long long start = timeInMilliseconds();
+        for (int i = 0; i < HASH_SLOTS_SIZE; i ++) {
+            int idx = ((i + start) & HASH_SLOTS_MASK);
+            dict *d = server.db[dbid].hash_slots[idx];
+            if (dictIsRehashing(d)) {
+                dictRehashMilliseconds(d, 1);
+                if (timeInMilliseconds() != start) {
+                    return 1; /* already used our millisecond for this loop... */
+                }
+            }
+        }
+        server.db[dbid].hash_slots_rehashing = 0;
         return 1; /* already used our millisecond for this loop... */
     }
     /* Expires */
@@ -1147,6 +1203,11 @@ int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
         if (server.sentinel_mode) sentinelTimer();
     }
 
+    run_with_period(1000) {
+        slotsmgrt_cleanup();
+        slotsmgrtAsyncCleanup();
+    }
+
     /* Cleanup expired MIGRATE cached sockets. */
     run_with_period(1000) {
         migrateCloseTimedoutSockets();
@@ -1783,12 +1844,14 @@ void resetServerStats(void) {
 }
 
 void initServer(void) {
-    int j;
+    int i, j;
 
     signal(SIGHUP, SIG_IGN);
     signal(SIGPIPE, SIG_IGN);
     setupSignalHandlers();
 
+    crc32_init();
+
     if (server.syslog_enabled) {
         openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,
             server.syslog_facility);
@@ -1820,6 +1883,14 @@ void initServer(void) {
     }
     server.db = zmalloc(sizeof(redisDb)*server.dbnum);
 
+    server.slotsmgrt_cached_sockfds = dictCreate(&migrateCacheDictType, NULL);
+    server.slotsmgrt_cached_clients = zmalloc(sizeof(slotsmgrtAsyncClient) * server.dbnum);
+    for (j = 0; j < server.dbnum; j ++) {
+        slotsmgrtAsyncClient *ac = &server.slotsmgrt_cached_clients[j];
+        memset(ac, 0, sizeof(*ac));
+    }
+    slotsmgrtInitLazyReleaseWorkerThread();
+
     /* Open the TCP listening socket for the user commands. */
     if (server.port != 0 &&
         listenToPort(server.port,server.ipfd,&server.ipfd_count) == C_ERR)
@@ -1852,6 +1923,11 @@ void initServer(void) {
         server.db[j].watched_keys = dictCreate(&keylistDictType,NULL);
         server.db[j].id = j;
         server.db[j].avg_ttl = 0;
+        for (i = 0; i < HASH_SLOTS_SIZE; i ++) {
+            server.db[j].hash_slots[i] = dictCreate(&hashSlotType, NULL);
+        }
+        server.db[j].hash_slots_rehashing = 0;
+        server.db[j].tagged_keys = zslCreate();
     }
     evictionPoolAlloc(); /* Initialize the LRU keys pool. */
     server.pubsub_channels = dictCreate(&keylistDictType,NULL);
@@ -2326,7 +2402,9 @@ int processCommand(client *c) {
     }
 
     /* Check if the user is authenticated */
-    if (server.requirepass && !c->authenticated && c->cmd->proc != authCommand)
+    if (server.requirepass && !c->authenticated
+            && c->cmd->proc != authCommand
+            && c->cmd->proc != slotsrestoreAsyncAuthCommand)
     {
         flagTransaction(c);
         addReply(c,shared.noautherr);
diff --git a/extern/redis-4.0.1/src/server.h b/extern/redis-4.0.1/src/server.h
index e3b56075..6b92a62a 100644
--- a/extern/redis-4.0.1/src/server.h
+++ b/extern/redis-4.0.1/src/server.h
@@ -249,6 +249,9 @@ typedef long long mstime_t; /* millisecond time type. */
 #define CLIENT_LUA_DEBUG_SYNC (1<<26)  /* EVAL debugging without fork() */
 #define CLIENT_MODULE (1<<27) /* Non connected client used by some module. */
 
+#define CLIENT_SLOTSMGRT_ASYNC_CACHED_CLIENT (1 << 0)
+#define CLIENT_SLOTSMGRT_ASYNC_NORMAL_CLIENT (1 << 1)
+
 /* Client block type (btype field in client structure)
  * if CLIENT_BLOCKED flag is set. */
 #define BLOCKED_NONE 0    /* Not blocked, no CLIENT_BLOCKED flag set. */
@@ -604,6 +607,16 @@ typedef struct redisObject {
 
 struct evictionPoolEntry; /* Defined in evict.c */
 
+void crc32_init();
+uint32_t crc32_checksum(const char *buf, int len);
+
+long long timeInMilliseconds(void);
+
+#define HASH_SLOTS_MASK 0x000003ff
+#define HASH_SLOTS_SIZE (HASH_SLOTS_MASK + 1)
+
+struct zskiplist;
+
 /* Redis database representation. There are multiple databases identified
  * by integers from 0 (the default database) up to the max configured
  * database. The database number is the 'id' field in the structure. */
@@ -613,6 +626,9 @@ typedef struct redisDb {
     dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/
     dict *ready_keys;           /* Blocked keys that received a PUSH */
     dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */
+    dict *hash_slots[HASH_SLOTS_SIZE];
+    int hash_slots_rehashing;
+    struct zskiplist *tagged_keys;
     int id;                     /* Database ID */
     long long avg_ttl;          /* Average TTL, just for stats */
 } redisDb;
@@ -723,6 +739,9 @@ typedef struct client {
     list *pubsub_patterns;  /* patterns a client is interested in (SUBSCRIBE) */
     sds peerid;             /* Cached peer ID. */
 
+    long slotsmgrt_flags;
+    list *slotsmgrt_fenceq;
+
     /* Response buffer */
     int bufpos;
     char buf[PROTO_REPLY_CHUNK_BYTES];
@@ -870,6 +889,19 @@ struct clusterState;
 #define CHILD_INFO_TYPE_RDB 0
 #define CHILD_INFO_TYPE_AOF 1
 
+typedef struct {
+    client *c;
+    int used;
+    sds host;
+    int port;
+    long long timeout;
+    long long lastuse;
+    long sending_msgs;
+    void *batched_iter;
+    list *blocked_list;
+} slotsmgrtAsyncClient;
+
+
 struct redisServer {
     /* General */
     pid_t pid;                  /* Main process pid. */
@@ -919,6 +951,11 @@ struct redisServer {
     int clients_paused;         /* True if clients are currently paused */
     mstime_t clients_pause_end_time; /* Time when we undo clients_paused */
     char neterr[ANET_ERR_LEN];   /* Error buffer for anet.c */
+
+    dict *slotsmgrt_cached_sockfds;
+    void *slotsmgrt_lazy_release;
+    slotsmgrtAsyncClient *slotsmgrt_cached_clients;
+
     dict *migrate_cached_sockets;/* MIGRATE cached sockets */
     uint64_t next_client_id;    /* Next client unique ID. Incremental. */
     int protected_mode;         /* Don't accept external connections. */
@@ -1425,6 +1462,8 @@ void discardTransaction(client *c);
 void flagTransaction(client *c);
 void execCommandPropagateMulti(client *c);
 
+#define OBJ_SHARED_REFCOUNT INT_MAX
+
 /* Redis object implementation */
 void decrRefCount(robj *o);
 void decrRefCountVoid(void *o);
@@ -1991,6 +2030,39 @@ void latencyCommand(client *c);
 void moduleCommand(client *c);
 void securityWarningCommand(client *c);
 
+void slotsinfoCommand(client *c);
+void slotsscanCommand(client *c);
+void slotsdelCommand(client *c);
+void slotsmgrtslotCommand(client *c);
+void slotsmgrtoneCommand(client *c);
+void slotsmgrttagslotCommand(client *c);
+void slotsmgrttagoneCommand(client *c);
+void slotshashkeyCommand(client *c);
+void slotscheckCommand(client *c);
+void slotsrestoreCommand(client *c);
+
+void slotsmgrtSlotAsyncCommand(client *c);
+void slotsmgrtTagSlotAsyncCommand(client *c);
+void slotsmgrtOneAsyncCommand(client *c);
+void slotsmgrtOneAsyncDumpCommand(client *c);
+void slotsmgrtTagOneAsyncCommand(client *c);
+void slotsmgrtTagOneAsyncDumpCommand(client *c);
+void slotsmgrtAsyncFenceCommand(client *c);
+void slotsmgrtAsyncCancelCommand(client *c);
+void slotsmgrtAsyncStatusCommand(client *c);
+void slotsmgrtExecWrapperCommand(client *c);
+void slotsrestoreAsyncCommand(client *c);
+void slotsrestoreAsyncAuthCommand(client *c);
+void slotsrestoreAsyncSelectCommand(client *c);
+void slotsrestoreAsyncAckCommand(client *c);
+
+void slotsmgrtAsyncCleanup();
+void slotsmgrtAsyncUnlinkClient(client *c);
+void slotsmgrtInitLazyReleaseWorkerThread();
+
+void slotsmgrt_cleanup();
+int slots_num(const sds s, uint32_t *pcrc, int *phastag);
+
 #if defined(__GNUC__)
 void *calloc(size_t count, size_t size) __attribute__ ((deprecated));
 void free(void *ptr) __attribute__ ((deprecated));
diff --git a/extern/redis-4.0.1/src/slots.c b/extern/redis-4.0.1/src/slots.c
new file mode 100644
index 00000000..7836fca0
--- /dev/null
+++ b/extern/redis-4.0.1/src/slots.c
@@ -0,0 +1,884 @@
+#include "server.h"
+
+extern void createDumpPayload(rio *payload, robj *o);
+extern int verifyDumpPayload(unsigned char *p, size_t len);
+
+static void *
+slots_tag(const sds s, int *plen) {
+    int i, j, n = sdslen(s);
+    for (i = 0; i < n && s[i] != '{'; i ++) {}
+    if (i == n) {
+        return NULL;
+    }
+    i ++;
+    for (j = i; j < n && s[j] != '}'; j ++) {}
+    if (j == n) {
+        return NULL;
+    }
+    if (plen != NULL) {
+        *plen = j - i;
+    }
+    return s + i;
+}
+
+int
+slots_num(const sds s, uint32_t *pcrc, int *phastag) {
+    int taglen;
+    int hastag = 0;
+    void *tag = slots_tag(s, &taglen);
+    if (tag == NULL) {
+        tag = s, taglen = sdslen(s);
+    } else {
+        hastag = 1;
+    }
+    uint32_t crc = crc32_checksum(tag, taglen);
+    if (pcrc != NULL) {
+        *pcrc = crc;
+    }
+    if (phastag != NULL) {
+        *phastag = hastag;
+    }
+    return crc & HASH_SLOTS_MASK;
+}
+
+static int
+parse_int(client *c, robj *obj, int *p) {
+    long v;
+    if (getLongFromObjectOrReply(c, obj, &v, NULL) != C_OK) {
+        return -1;
+    }
+    if (v < INT_MIN || v > INT_MAX) {
+        addReplyError(c, "value is out of range");
+        return -1;
+    } else {
+        *p = v;
+        return 0;
+    }
+}
+
+static int
+parse_timeout(client *c, robj *obj, int *p) {
+    int v;
+    if (parse_int(c, obj, &v) != 0) {
+        return -1;
+    }
+    if (v < 0) {
+        addReplyErrorFormat(c, "invalid timeout = %d", v);
+        return -1;
+    }
+    *p = (v == 0) ? 100 : v;
+    return 0;
+}
+
+static int
+parse_slot(client *c, robj *obj, int *p) {
+    int v;
+    if (parse_int(c, obj, &v) != 0) {
+        return -1;
+    }
+    if (v < 0 || v >= HASH_SLOTS_SIZE) {
+        addReplyErrorFormat(c, "invalid slot number = %d", v);
+        return -1;
+    }
+    *p = v;
+    return 0;
+}
+
+/* *
+ * slotshashkey [key1 key2...]
+ * */
+void
+slotshashkeyCommand(client *c) {
+    int i;
+    addReplyMultiBulkLen(c, c->argc - 1);
+    for (i = 1; i < c->argc; i ++) {
+        robj *key = c->argv[i];
+        addReplyLongLong(c, slots_num(key->ptr, NULL, NULL));
+    }
+}
+
+/* *
+ * slotsinfo [start] [count]
+ * */
+void
+slotsinfoCommand(client *c) {
+    int slots_slot[HASH_SLOTS_SIZE];
+    int slots_size[HASH_SLOTS_SIZE];
+    int n = 0, beg = 0, end = HASH_SLOTS_SIZE;
+    if (c->argc >= 2) {
+        if (parse_slot(c, c->argv[1], &beg) != 0) {
+            return;
+        }
+    }
+    if (c->argc >= 3) {
+        int v;
+        if (parse_int(c, c->argv[2], &v) != 0) {
+            return;
+        }
+        if (v < 0) {
+            addReplyErrorFormat(c, "invalid slot count = %d", v);
+            return;
+        }
+        if (beg + v < end) {
+            end = beg + v;
+        }
+    }
+    if (c->argc >= 4) {
+        addReplyErrorFormat(c, "wrong number of arguments for 'slotsinfo' command");
+        return;
+    }
+    int i;
+    for (i = beg; i < end; i ++) {
+        int s = dictSize(c->db->hash_slots[i]);
+        if (s == 0) {
+            continue;
+        }
+        slots_slot[n] = i;
+        slots_size[n] = s;
+        n ++;
+    }
+    addReplyMultiBulkLen(c, n);
+    for (i = 0; i < n; i ++) {
+        addReplyMultiBulkLen(c, 2);
+        addReplyLongLong(c, slots_slot[i]);
+        addReplyLongLong(c, slots_size[i]);
+    }
+}
+
+typedef struct {
+    int fd;
+    int db;
+    int authorized;
+    time_t lasttime;
+} slotsmgrt_sockfd;
+
+static slotsmgrt_sockfd *
+slotsmgrt_get_sockfd(client *c, sds host, sds port, int timeout) {
+    sds name = sdsempty();
+    name = sdscatlen(name, host, sdslen(host));
+    name = sdscatlen(name, ":", 1);
+    name = sdscatlen(name, port, sdslen(port));
+
+    slotsmgrt_sockfd *pfd = dictFetchValue(server.slotsmgrt_cached_sockfds, name);
+    if (pfd != NULL) {
+        sdsfree(name);
+        pfd->lasttime = server.unixtime;
+        return pfd;
+    }
+
+    int fd = anetTcpNonBlockConnect(server.neterr, host, atoi(port));
+    if (fd == -1) {
+        serverLog(LL_WARNING, "slotsmgrt: connect to target %s:%s, error = '%s'",
+                host, port, server.neterr);
+        sdsfree(name);
+        addReplyErrorFormat(c,"Can't connect to target node: %s", server.neterr);
+        return NULL;
+    }
+    anetEnableTcpNoDelay(server.neterr, fd);
+    if ((aeWait(fd, AE_WRITABLE, timeout) & AE_WRITABLE) == 0) {
+        serverLog(LL_WARNING, "slotsmgrt: connect to target %s:%s, aewait error = '%s'",
+                host, port, server.neterr);
+        sdsfree(name);
+        close(fd);
+        addReplySds(c, sdsnew("-IOERR error or timeout connecting to the client\r\n"));
+        return NULL;
+    }
+    serverLog(LL_WARNING, "slotsmgrt: connect to target %s:%s", host, port);
+
+    pfd = zmalloc(sizeof(*pfd));
+    pfd->fd = fd;
+    pfd->db = -1;
+    pfd->authorized = (server.requirepass == NULL) ? 1 : 0;
+    pfd->lasttime = server.unixtime;
+    dictAdd(server.slotsmgrt_cached_sockfds, name, pfd);
+    return pfd;
+}
+
+static void
+slotsmgrt_close_socket(sds host, sds port) {
+    sds name = sdsempty();
+    name = sdscatlen(name, host, sdslen(host));
+    name = sdscatlen(name, ":", 1);
+    name = sdscatlen(name, port, sdslen(port));
+
+    slotsmgrt_sockfd *pfd = dictFetchValue(server.slotsmgrt_cached_sockfds, name);
+    if (pfd == NULL) {
+        serverLog(LL_WARNING, "slotsmgrt: close target %s:%s again", host, port);
+        sdsfree(name);
+        return;
+    } else {
+        serverLog(LL_WARNING, "slotsmgrt: close target %s:%s", host, port);
+    }
+    dictDelete(server.slotsmgrt_cached_sockfds, name);
+    close(pfd->fd);
+    zfree(pfd);
+    sdsfree(name);
+}
+
+void
+slotsmgrt_cleanup() {
+    dictIterator *di = dictGetSafeIterator(server.slotsmgrt_cached_sockfds);
+    dictEntry *de;
+    while((de = dictNext(di)) != NULL) {
+        slotsmgrt_sockfd *pfd = dictGetVal(de);
+        if ((server.unixtime - pfd->lasttime) > 15) {
+            serverLog(LL_WARNING, "slotsmgrt: timeout target %s, lasttime = %ld, now = %ld",
+                   (char *)dictGetKey(de), pfd->lasttime, server.unixtime);
+            dictDelete(server.slotsmgrt_cached_sockfds, dictGetKey(de));
+            close(pfd->fd);
+            zfree(pfd);
+        }
+    }
+    dictReleaseIterator(di);
+}
+
+static int
+slotsmgrt(client *c, sds host, sds port, slotsmgrt_sockfd *pfd, int db, int timeout, robj *keys[], robj *vals[], int n) {
+    rio cmd;
+    rioInitWithBuffer(&cmd, sdsempty());
+
+    int needauth = 0;
+    if (pfd->authorized == 0 && server.requirepass != NULL) {
+        needauth = 1;
+        serverAssertWithInfo(c, NULL, rioWriteBulkCount(&cmd, '*', 2));
+        serverAssertWithInfo(c, NULL, rioWriteBulkString(&cmd, "AUTH", 4));
+        serverAssertWithInfo(c, NULL, rioWriteBulkString(&cmd, server.requirepass, strlen(server.requirepass)));
+    }
+
+    int selectdb = 0;
+    if (pfd->db != db) {
+        selectdb = 1;
+        serverAssertWithInfo(c, NULL, rioWriteBulkCount(&cmd, '*', 2));
+        serverAssertWithInfo(c, NULL, rioWriteBulkString(&cmd, "SELECT", 6));
+        serverAssertWithInfo(c, NULL, rioWriteBulkLongLong(&cmd, db));
+    }
+
+    serverAssertWithInfo(c, NULL, rioWriteBulkCount(&cmd, '*', 1 + 3 * n));
+    serverAssertWithInfo(c, NULL, rioWriteBulkString(&cmd, "SLOTSRESTORE", 12));
+
+    sds onekey = NULL;
+    for (int i = 0; i < n; i ++) {
+        robj *key = keys[i], *val = vals[i];
+        long long ttl = 0, expireat = getExpire(c->db, key);
+        if (expireat != -1) {
+            ttl = expireat - mstime();
+            if (ttl < 1) {
+                ttl = 1;
+            }
+        }
+        sds skey = key->ptr;
+        serverAssertWithInfo(c, NULL, rioWriteBulkString(&cmd, skey, sdslen(skey)));
+        serverAssertWithInfo(c, NULL, rioWriteBulkLongLong(&cmd, ttl));
+        do {
+            rio pld;
+            createDumpPayload(&pld, val);
+            sds buf = pld.io.buffer.ptr;
+            serverAssertWithInfo(c, NULL, rioWriteBulkString(&cmd, buf, sdslen(buf)));
+            sdsfree(buf);
+        } while (0);
+        if (onekey == NULL) {
+            onekey = skey;
+        }
+    }
+
+    do {
+        sds buf = cmd.io.buffer.ptr;
+        size_t pos = 0, towrite;
+        int nwritten = 0;
+        while ((towrite = sdslen(buf) - pos) > 0) {
+            towrite = (towrite > (64 * 1024) ? (64 * 1024) : towrite);
+            nwritten = syncWrite(pfd->fd, buf + pos, towrite, timeout);
+            if (nwritten != (signed)towrite) {
+                serverLog(LL_WARNING, "slotsmgrt: writing to target %s:%s, error '%s', "
+                        "nkeys = %d, onekey = '%s', cmd.len = %ld, pos = %ld, towrite = %ld",
+                        host, port, server.neterr, n, onekey, sdslen(buf), pos, towrite);
+                addReplySds(c, sdsnew("-IOERR error or timeout writing to target\r\n"));
+                sdsfree(buf);
+                return -1;
+            }
+            pos += nwritten;
+        }
+        sdsfree(buf);
+    } while (0);
+
+    do {
+        char buf[1024];
+        if (needauth) {
+            if (syncReadLine(pfd->fd, buf, sizeof(buf), timeout) <= 0) {
+                serverLog(LL_WARNING, "slotsmgrt: auth failed, reading from target %s:%s: nkeys = %d, onekey = '%s', error = '%s'",
+                        host, port, n, onekey, server.neterr);
+                addReplySds(c, sdsnew("-IOERR error or timeout reading from target\r\n"));
+                return -1;
+            }
+            if (buf[0] != '+') {
+                serverLog(LL_WARNING, "slotsmgrt: auth failed, reading from target %s:%s: nkeys = %d, onekey = '%s', response = '%s'",
+                        host, port, n, onekey, buf);
+                addReplyError(c, "error on slotsrestore, auth failed");
+                return -1;
+            }
+            pfd->authorized = 1;
+        }
+
+        if (selectdb) {
+            if (syncReadLine(pfd->fd, buf, sizeof(buf), timeout) <= 0) {
+                serverLog(LL_WARNING, "slotsmgrt: select failed, reading from target %s:%s: nkeys = %d, onekey = '%s', error = '%s'",
+                        host, port, n, onekey, server.neterr);
+                addReplySds(c, sdsnew("-IOERR error or timeout reading from target\r\n"));
+                return -1;
+            }
+            if (buf[0] != '+') {
+                serverLog(LL_WARNING, "slotsmgrt: select failed, reading from target %s:%s: nkeys = %d, onekey = '%s', response = '%s'",
+                        host, port, n, onekey, buf);
+                addReplyError(c, "error on slotsrestore, select failed");
+                return -1;
+            }
+            pfd->db = db;
+        }
+
+        if (syncReadLine(pfd->fd, buf, sizeof(buf), timeout) <= 0) {
+            serverLog(LL_WARNING, "slotsmgrt: migration failed, reading from target %s:%s: nkeys = %d, onekey = '%s', error = '%s'",
+                    host, port, n, onekey, server.neterr);
+            addReplySds(c, sdsnew("-IOERR error or timeout reading from target\r\n"));
+            return -1;
+        }
+        if (buf[0] == '-') {
+            serverLog(LL_WARNING, "slotsmgrt: migration failed, reading from target %s:%s: nkeys = %d, onekey = '%s', response = '%s'",
+                    host, port, n, onekey, buf);
+            addReplyError(c, "error on slotsrestore, migration failed");
+            return -1;
+        }
+    } while (0);
+
+    pfd->lasttime = server.unixtime;
+
+    serverLog(LL_VERBOSE, "slotsmgrt: migrate to %s:%s, nkeys = %d, onekey = '%s'", host, port, n, onekey);
+    return 0;
+}
+
+static void
+slotsremove(client *c, robj **keys, int n, int rewrite) {
+    for (int i = 0; i < n; i ++) {
+        dbDelete(c->db, keys[i]);
+        signalModifiedKey(c->db, keys[i]);
+        server.dirty ++;
+    }
+    if (!rewrite) {
+        return;
+    }
+    for (int i = 0; i < n; i ++) {
+        incrRefCount(keys[i]);
+    }
+    for (int i = 0; i < c->argc; i ++) {
+        decrRefCount(c->argv[i]);
+    }
+    zfree(c->argv);
+    c->argc = n + 1;
+    c->argv = zmalloc(sizeof(robj *) * c->argc);
+    c->argv[0] = createStringObject("DEL", 3);
+    for (int i = 0; i < n; i ++) {
+        c->argv[i + 1] = keys[i];
+    }
+    c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
+    serverAssertWithInfo(c, NULL, c->cmd != NULL);
+}
+
+/* *
+ * do migrate a key-value for slotsmgrt/slotsmgrtone commands
+ * return value:
+ *    -1 - error happens
+ *   >=0 - # of success migration (0 or 1)
+ * */
+static int
+slotsmgrtone_command(client *c, sds host, sds port, int timeout, robj *key) {
+    slotsmgrt_sockfd *pfd = slotsmgrt_get_sockfd(c, host, port, timeout);
+    if (pfd == NULL) {
+        return -1;
+    }
+
+    robj *val = lookupKeyWrite(c->db, key);
+    if (val == NULL) {
+        return 0;
+    }
+    robj *keys[] = {key};
+    robj *vals[] = {val};
+    if (slotsmgrt(c, host, port, pfd, c->db->id, timeout, keys, vals, 1) != 0) {
+        slotsmgrt_close_socket(host, port);
+        return -1;
+    }
+    slotsremove(c, keys, 1, 1);
+    return 1;
+}
+
+/* *
+ * slotsmgrtslot host port timeout slot
+ * */
+void
+slotsmgrtslotCommand(client *c) {
+    sds host = c->argv[1]->ptr;
+    sds port = c->argv[2]->ptr;
+    int timeout, slot;
+    if (parse_timeout(c, c->argv[3], &timeout) != 0) {
+        return;
+    }
+    if (parse_slot(c, c->argv[4], &slot) != 0) {
+        return;
+    }
+
+    dict *d = c->db->hash_slots[slot];
+    int succ = 0;
+    do {
+        const dictEntry *de = dictGetRandomKey(d);
+        if (de == NULL) {
+            break;
+        }
+        sds skey = dictGetKey(de);
+        robj *key = createStringObject(skey, sdslen(skey));
+        succ = slotsmgrtone_command(c, host, port, timeout, key);
+        decrRefCount(key);
+        if (succ < 0) {
+            return;
+        }
+    } while (0);
+    addReplyMultiBulkLen(c, 2);
+    addReplyLongLong(c, succ);
+    addReplyLongLong(c, dictSize(d));
+}
+
+/* *
+ * slotsmgrtone host port timeout key
+ * */
+void
+slotsmgrtoneCommand(client *c) {
+    sds host = c->argv[1]->ptr;
+    sds port = c->argv[2]->ptr;
+    int timeout;
+    if (parse_timeout(c, c->argv[3], &timeout) != 0) {
+        return;
+    }
+
+    robj *key = c->argv[4];
+    int succ = slotsmgrtone_command(c, host, port, timeout, key);
+    if (succ < 0) {
+        return;
+    }
+    addReplyLongLong(c, succ);
+}
+
+static void
+slotsScanSdsKeyCallback(void *l, const dictEntry *de) {
+    sds skey = dictGetKey(de);
+    robj *key = createStringObject(skey, sdslen(skey));
+    listAddNodeTail((list *)l, key);
+}
+
+/* *
+ * slotsdel slot1 [slot2 ...]
+ * */
+void
+slotsdelCommand(client *c) {
+    int slots_slot[HASH_SLOTS_SIZE];
+    int n = 0;
+    if (c->argc <= 1) {
+        addReplyErrorFormat(c, "wrong number of arguments for 'slotsdel' command");
+        return;
+    }
+    int i;
+    for (i = 1; i < c->argc; i ++) {
+        int slot;
+        if (parse_slot(c, c->argv[i], &slot) != 0) {
+            return;
+        }
+        slots_slot[n] = slot;
+        n ++;
+    }
+    for (i = 0; i < n; i ++) {
+        dict *d = c->db->hash_slots[slots_slot[i]];
+        int s = dictSize(d);
+        if (s == 0) {
+            continue;
+        }
+        list *l = listCreate();
+        listSetFreeMethod(l, decrRefCountVoid);
+        unsigned long cursor = 0;
+        do {
+            cursor = dictScan(d, cursor, slotsScanSdsKeyCallback, NULL, l);
+            while (1) {
+                listNode *head = listFirst(l);
+                if (head == NULL) {
+                    break;
+                }
+                robj *key = listNodeValue(head);
+                robj *keys[] = {key};
+                slotsremove(c, keys, 1, 0);
+                listDelNode(l, head);
+            }
+        } while (cursor != 0);
+        listRelease(l);
+    }
+    addReplyMultiBulkLen(c, n);
+    for (i = 0; i < n; i ++) {
+        int n = slots_slot[i];
+        int s = dictSize(c->db->hash_slots[n]);
+        addReplyMultiBulkLen(c, 2);
+        addReplyLongLong(c, n);
+        addReplyLongLong(c, s);
+    }
+}
+
+/* *
+ * slotscheck
+ * */
+void
+slotscheckCommand(client *c) {
+    sds bug = NULL;
+    int i;
+    for (i = 0; i < HASH_SLOTS_SIZE && bug == NULL; i ++) {
+        dict *d = c->db->hash_slots[i];
+        if (dictSize(d) == 0) {
+            continue;
+        }
+        list *l = listCreate();
+        listSetFreeMethod(l, decrRefCountVoid);
+        unsigned long cursor = 0;
+        do {
+            cursor = dictScan(d, cursor, slotsScanSdsKeyCallback, NULL, l);
+            while (1) {
+                listNode *head = listFirst(l);
+                if (head == NULL) {
+                    break;
+                }
+                robj *key = listNodeValue(head);
+                if (lookupKeyRead(c->db, key) == NULL) {
+                    if (bug == NULL) {
+                        bug = sdsdup(key->ptr);
+                    }
+                }
+                listDelNode(l, head);
+            }
+        } while (cursor != 0 && bug == NULL);
+        listRelease(l);
+    }
+    if (bug != NULL) {
+        addReplyErrorFormat(c, "step 1, miss = '%s'", bug);
+        sdsfree(bug);
+        return;
+    }
+    do {
+        dict *d = c->db->dict;
+        if (dictSize(d) == 0) {
+            break;
+        }
+        list *l = listCreate();
+        listSetFreeMethod(l, decrRefCountVoid);
+        unsigned long cursor = 0;
+        do {
+            cursor = dictScan(d, cursor, slotsScanSdsKeyCallback, NULL, l);
+            while (1) {
+                listNode *head = listFirst(l);
+                if (head == NULL) {
+                    break;
+                }
+                robj *key = listNodeValue(head);
+                int slot = slots_num(key->ptr, NULL, NULL);
+                if (dictFind(c->db->hash_slots[slot], key->ptr) == NULL) {
+                    if (bug == NULL) {
+                        bug = sdsdup(key->ptr);
+                    }
+                }
+                listDelNode(l, head);
+            }
+        } while (cursor != 0 && bug == NULL);
+        listRelease(l);
+    } while (0);
+    if (bug != NULL) {
+        addReplyErrorFormat(c, "step 2, miss = '%s'", bug);
+        sdsfree(bug);
+        return;
+    }
+    zskiplistNode *node = c->db->tagged_keys->header->level[0].forward;
+    while (node != NULL && bug == NULL) {
+        robj *key = createObject(OBJ_STRING, sdsdup(node->ele));
+        if (lookupKeyRead(c->db, key) == NULL) {
+            bug = sdsdup(node->ele);
+        }
+        decrRefCount(key);
+        node = node->level[0].forward;
+    }
+    if (bug != NULL) {
+        addReplyErrorFormat(c, "step 3, miss = '%s'", bug);
+        sdsfree(bug);
+        return;
+    }
+    addReply(c, shared.ok);
+}
+
+/* *
+ * slotsrestore key ttl val [key ttl val ...]
+ * */
+void
+slotsrestoreCommand(client *c) {
+    if (c->argc < 4 || (c->argc - 1) % 3 != 0) {
+        addReplyErrorFormat(c, "wrong number of arguments for 'slotsrestore' command");
+        return;
+    }
+    int n = (c->argc - 1) / 3;
+
+    long long *ttls = zmalloc(sizeof(long long) * n);
+    robj **vals = zmalloc(sizeof(robj *) * n);
+    for (int i = 0; i < n; i ++) {
+        vals[i] = NULL;
+    }
+
+    for (int i = 0; i < n; i ++) {
+        robj *key = c->argv[i * 3 + 1];
+        robj *ttl = c->argv[i * 3 + 2];
+        robj *val = c->argv[i * 3 + 3];
+        if (lookupKeyWrite(c->db, key) != NULL) {
+            serverLog(LL_WARNING, "slotsrestore: slot = %d, key = '%s' already exists",
+                    slots_num(key->ptr, NULL, NULL), (char *)key->ptr);
+        }
+        if (getLongLongFromObjectOrReply(c, ttl, &ttls[i], NULL) != C_OK) {
+            goto cleanup;
+        } else if (ttls[i] < 0) {
+            addReplyError(c, "invalid ttl value, must be >= 0");
+            goto cleanup;
+        }
+        rio payload;
+        int type;
+        if (verifyDumpPayload(val->ptr, sdslen(val->ptr)) != C_OK) {
+            addReplyError(c, "dump payload version or checksum are wrong");
+            goto cleanup;
+        }
+        rioInitWithBuffer(&payload, val->ptr);
+        if (((type = rdbLoadObjectType(&payload)) == -1) ||
+                ((vals[i] = rdbLoadObject(type, &payload)) == NULL)) {
+            addReplyError(c, "bad data format");
+            goto cleanup;
+        }
+    }
+
+    for (int i = 0; i < n; i ++) {
+        robj *key = c->argv[i * 3 + 1];
+        long long ttl = ttls[i];
+        robj *val = vals[i];
+        dbDelete(c->db, key);
+        dbAdd(c->db, key, val);
+        incrRefCount(val);
+        if (ttl) {
+            setExpire(c, c->db, key, mstime() + ttl);
+        }
+        signalModifiedKey(c->db, key);
+        server.dirty ++;
+    }
+    addReply(c, shared.ok);
+
+cleanup:
+    for (int i = 0; i < n; i ++) {
+        if (vals[i] != NULL) {
+            decrRefCount(vals[i]);
+        }
+    }
+    zfree(vals);
+    zfree(ttls);
+}
+
+/* *
+ * do migrate mutli key-value(s) for {slotsmgrt/slotsmgrtone}with tag commands
+ * return value:
+ *    -1 - error happens
+ *   >=0 - # of success migration
+ * */
+static int
+slotsmgrttag_command(client *c, sds host, sds port, int timeout, robj *key) {
+    uint32_t crc;
+    int hastag;
+    int slot = slots_num(key->ptr, &crc, &hastag);
+    if (!hastag) {
+        return slotsmgrtone_command(c, host, port, timeout, key);
+    }
+
+    slotsmgrt_sockfd *pfd = slotsmgrt_get_sockfd(c, host, port, timeout);
+    if (pfd == NULL) {
+        return -1;
+    }
+
+    dict *d = c->db->hash_slots[slot];
+    if (dictSize(d) == 0) {
+        return 0;
+    }
+
+    zrangespec range;
+    range.min = (double)crc;
+    range.minex = 0;
+    range.max = (double)crc;
+    range.maxex = 0;
+
+    list *l = listCreate();
+    listSetFreeMethod(l, decrRefCountVoid);
+
+    zskiplistNode *node = zslFirstInRange(c->db->tagged_keys, &range);
+    while (node != NULL && node->score == (double)crc) {
+        robj *listNode = createObject(OBJ_STRING, sdsdup(node->ele));
+        listAddNodeTail(l, listNode);
+        node = node->level[0].forward;
+    }
+
+    int max = listLength(l);
+    if (max == 0) {
+        listRelease(l);
+        return 0;
+    }
+
+    robj **keys = zmalloc(sizeof(robj *) * max);
+    robj **vals = zmalloc(sizeof(robj *) * max);
+
+    int n = 0;
+    for (int i = 0; i < max; i ++) {
+        listNode *head = listFirst(l);
+        robj *key = listNodeValue(head);
+        robj *val = lookupKeyWrite(c->db, key);
+        if (val != NULL) {
+            keys[n] = key;
+            vals[n] = val;
+            n ++;
+            incrRefCount(key);
+            incrRefCount(val);
+        }
+        listDelNode(l, head);
+    }
+
+    int ret = 0;
+    if (n != 0) {
+        if (slotsmgrt(c, host, port, pfd, c->db->id, timeout, keys, vals, n) != 0) {
+            slotsmgrt_close_socket(host, port);
+            ret = -1;
+        } else {
+            slotsremove(c, keys, n, 1);
+            ret = n;
+        }
+    }
+
+    listRelease(l);
+    for (int i = 0; i < n; i ++) {
+        decrRefCount(keys[i]);
+        decrRefCount(vals[i]);
+    }
+    zfree(keys);
+    zfree(vals);
+    return ret;
+}
+
+/* *
+ * slotsmgrttagslot host port timeout slot
+ * */
+void
+slotsmgrttagslotCommand(client *c) {
+    sds host = c->argv[1]->ptr;
+    sds port = c->argv[2]->ptr;
+    int timeout, slot;
+    if (parse_timeout(c, c->argv[3], &timeout) != 0) {
+        return;
+    }
+    if (parse_slot(c, c->argv[4], &slot) != 0) {
+        return;
+    }
+
+    dict *d = c->db->hash_slots[slot];
+    int succ = 0;
+    do {
+        const dictEntry *de = dictGetRandomKey(d);
+        if (de == NULL) {
+            break;
+        }
+        sds skey = dictGetKey(de);
+        robj *key = createStringObject(skey, sdslen(skey));
+        succ = slotsmgrttag_command(c, host, port, timeout, key);
+        decrRefCount(key);
+        if (succ < 0) {
+            return;
+        }
+    } while (0);
+    addReplyMultiBulkLen(c, 2);
+    addReplyLongLong(c, succ);
+    addReplyLongLong(c, dictSize(d));
+}
+
+/* *
+ * slotsmgrttagone host port timeout key
+ * */
+void
+slotsmgrttagoneCommand(client *c) {
+    sds host = c->argv[1]->ptr;
+    sds port = c->argv[2]->ptr;
+    int timeout;
+    if (parse_timeout(c, c->argv[3], &timeout) != 0) {
+        return;
+    }
+
+    robj *key = c->argv[4];
+    int succ = slotsmgrttag_command(c, host, port, timeout, key);
+    if (succ < 0) {
+        return;
+    }
+    addReplyLongLong(c, succ);
+}
+
+/* *
+ * slotsscan slotnum cursor [COUNT count]
+ * */
+void
+slotsscanCommand(client *c) {
+    int slot;
+    if (parse_slot(c, c->argv[1], &slot) != 0) {
+        return;
+    }
+    unsigned long cursor;
+    if (parseScanCursorOrReply(c, c->argv[2], &cursor) == C_ERR) {
+        return;
+    }
+    unsigned long count = 10;
+    if (c->argc != 3 && c->argc != 5) {
+        addReplyErrorFormat(c, "wrong number of arguments for 'slotsscan' command");
+        return;
+    }
+    if (c->argc == 5) {
+        if (strcasecmp(c->argv[3]->ptr, "count") != 0) {
+            addReply(c, shared.syntaxerr);
+            return;
+        }
+        int v;
+        if (parse_int(c, c->argv[4], &v) != 0) {
+            return;
+        }
+        if (v < 1) {
+            addReply(c, shared.syntaxerr);
+            return;
+        }
+        count = v;
+    }
+    dict *d = c->db->hash_slots[slot];
+    list *l = listCreate();
+    listSetFreeMethod(l, decrRefCountVoid);
+
+    long loops = count * 10;
+    do {
+        cursor = dictScan(d, cursor, slotsScanSdsKeyCallback, NULL, l);
+        loops --;
+    } while (cursor != 0 && loops > 0 && listLength(l) < count);
+
+    addReplyMultiBulkLen(c, 2);
+    addReplyBulkLongLong(c, cursor);
+
+    addReplyMultiBulkLen(c, listLength(l));
+    while (1) {
+        listNode *head = listFirst(l);
+        if (head == NULL) {
+            break;
+        }
+        robj *key = listNodeValue(head);
+        addReplyBulk(c, key);
+        listDelNode(l, head);
+    }
+
+    listRelease(l);
+}
diff --git a/extern/redis-4.0.1/src/slots_async.c b/extern/redis-4.0.1/src/slots_async.c
new file mode 100644
index 00000000..fa0c9094
--- /dev/null
+++ b/extern/redis-4.0.1/src/slots_async.c
@@ -0,0 +1,1769 @@
+#include "server.h"
+
+/* ============================ Worker Thread for Lazy Release ============================= */
+
+typedef struct {
+    pthread_t thread;
+    pthread_mutex_t mutex;
+    pthread_cond_t cond;
+    list *objs;
+} lazyReleaseWorker;
+
+static void *
+lazyReleaseWorkerMain(void *args) {
+    lazyReleaseWorker *p = args;
+    while (1) {
+        pthread_mutex_lock(&p->mutex);
+        while (listLength(p->objs) == 0) {
+            pthread_cond_wait(&p->cond, &p->mutex);
+        }
+        listNode *head = listFirst(p->objs);
+        robj *o = listNodeValue(head);
+        listDelNode(p->objs, head);
+        pthread_mutex_unlock(&p->mutex);
+
+        decrRefCount(o);
+    }
+    return NULL;
+}
+
+static void
+lazyReleaseObject(robj *o) {
+    serverAssert(o->refcount == 1);
+    lazyReleaseWorker *p = server.slotsmgrt_lazy_release;
+    pthread_mutex_lock(&p->mutex);
+    if (listLength(p->objs) == 0) {
+        pthread_cond_broadcast(&p->cond);
+    }
+    listAddNodeTail(p->objs, o);
+    pthread_mutex_unlock(&p->mutex);
+}
+
+static lazyReleaseWorker *
+createLazyReleaseWorkerThread() {
+    lazyReleaseWorker *p = zmalloc(sizeof(lazyReleaseWorker));
+    pthread_mutex_init(&p->mutex, NULL);
+    pthread_cond_init(&p->cond, NULL);
+    p->objs = listCreate();
+    if (pthread_create(&p->thread, NULL, lazyReleaseWorkerMain, p) != 0) {
+        serverLog(LL_WARNING,"Fatal: Can't initialize Worker Thread for Lazy Release Jobs.");
+        exit(1);
+    }
+    return p;
+}
+
+void
+slotsmgrtInitLazyReleaseWorkerThread() {
+    server.slotsmgrt_lazy_release = createLazyReleaseWorkerThread();
+}
+
+/* ============================ Iterator for Data Migration ================================ */
+
+#define STAGE_PREPARE 0
+#define STAGE_PAYLOAD 1
+#define STAGE_CHUNKED 2
+#define STAGE_FILLTTL 3
+#define STAGE_DONE    4
+
+typedef struct {
+    int stage;
+    robj *key;
+    robj *val;
+    long long expire;
+    unsigned long cursor;
+    unsigned long lindex;
+    unsigned long zindex;
+    unsigned long chunked_msgs;
+} singleObjectIterator;
+
+static singleObjectIterator *
+createSingleObjectIterator(robj *key) {
+    singleObjectIterator *it = zmalloc(sizeof(singleObjectIterator));
+    it->stage = STAGE_PREPARE;
+    it->key = key;
+    incrRefCount(it->key);
+    it->val = NULL;
+    it->expire = 0;
+    it->cursor = 0;
+    it->lindex = 0;
+    it->zindex = 0;
+    it->chunked_msgs = 0;
+    return it;
+}
+
+static void
+freeSingleObjectIterator(singleObjectIterator *it) {
+    if (it->val != NULL) {
+        decrRefCount(it->val);
+    }
+    decrRefCount(it->key);
+    zfree(it);
+}
+
+static void
+freeSingleObjectIteratorVoid(void *it) {
+    freeSingleObjectIterator(it);
+}
+
+static int
+singleObjectIteratorHasNext(singleObjectIterator *it) {
+    return it->stage != STAGE_DONE;
+}
+
+static size_t
+sdslenOrElse(robj *o, size_t len) {
+    return sdsEncodedObject(o) ? sdslen(o->ptr) : len;
+}
+
+static void
+singleObjectIteratorScanCallback(void *data, const dictEntry *de) {
+    void **pd = (void **)data;
+    list *l = pd[0];
+    robj *o = pd[1];
+    long long *n = pd[2];
+
+    robj *objs[2] = {NULL, NULL};
+    switch (o->type) {
+    case OBJ_HASH:
+        objs[0] = dictGetKey(de);
+        objs[1] = dictGetVal(de);
+        break;
+    case OBJ_SET:
+        objs[0] = dictGetKey(de);
+        break;
+    }
+    for (int i = 0; i < 2; i ++) {
+        if (objs[i] != NULL) {
+            incrRefCount(objs[i]);
+            *n += sdslenOrElse(objs[i], 8);
+            listAddNodeTail(l, objs[i]);
+        }
+    }
+}
+
+static uint64_t
+convertDoubleToRawBits(double value) {
+    union {
+        double d;
+        uint64_t u;
+    } fp;
+    fp.d = value;
+    return fp.u;
+}
+
+static double
+convertRawBitsToDouble(uint64_t value) {
+    union {
+        double d;
+        uint64_t u;
+    } fp;
+    fp.u = value;
+    return fp.d;
+}
+
+static robj *
+createRawStringObjectFromUint64(uint64_t v) {
+    uint64_t p = intrev64ifbe(v);
+    return createRawStringObject((char *)&p, sizeof(p));
+}
+
+static int
+getUint64FromRawStringObject(robj *o, uint64_t *p) {
+    if (sdsEncodedObject(o) && sdslen(o->ptr) == sizeof(uint64_t)) {
+        *p = intrev64ifbe(*(uint64_t *)(o->ptr));
+        return C_OK;
+    }
+    return C_ERR;
+}
+
+static long
+numberOfRestoreCommandsFromObject(robj *val, long long maxbulks) {
+    long long numbulks = 0;
+    switch (val->type) {
+    case OBJ_LIST:
+        if (val->encoding == OBJ_ENCODING_QUICKLIST) {
+            numbulks = listTypeLength(val);
+        }
+        break;
+    case OBJ_HASH:
+        if (val->encoding == OBJ_ENCODING_HT) {
+            numbulks = hashTypeLength(val) * 2;
+        }
+        break;
+    case OBJ_SET:
+        if (val->encoding == OBJ_ENCODING_HT) {
+            numbulks = setTypeSize(val);
+        }
+        break;
+    case OBJ_ZSET:
+        if (val->encoding == OBJ_ENCODING_SKIPLIST) {
+            numbulks = zsetLength(val) * 2;
+        }
+        break;
+    }
+    if (numbulks <= maxbulks) {
+        return 1;
+    }
+    return (numbulks + maxbulks - 1) / maxbulks;
+}
+
+static long
+estimateNumberOfRestoreCommands(redisDb *db, robj *key, long long maxbulks) {
+    robj *val = lookupKeyWrite(db, key);
+    if (val != NULL) {
+        return numberOfRestoreCommandsFromObject(val, maxbulks);
+    }
+    return 0;
+}
+
+extern void createDumpPayload(rio *payload, robj *o);
+extern zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank);
+
+static slotsmgrtAsyncClient *getSlotsmgrtAsyncClient(int db);
+
+static int
+singleObjectIteratorNext(client *c, singleObjectIterator *it,
+        long long timeout, unsigned int maxbulks, unsigned int maxbytes) {
+    /* *
+     * STAGE_PREPARE ---> STAGE_PAYLOAD ---> STAGE_DONE
+     *     |                                      A
+     *     V                                      |
+     *     +------------> STAGE_CHUNKED ---> STAGE_FILLTTL
+     *                      A       |
+     *                      |       V
+     *                      +-------+
+     * */
+
+    robj *key = it->key;
+
+    if (it->stage == STAGE_PREPARE) {
+        robj *val = lookupKeyWrite(c->db, key);
+        if (val == NULL) {
+            it->stage = STAGE_DONE;
+            return 0;
+        }
+        it->val = val;
+        incrRefCount(it->val);
+        it->expire = getExpire(c->db, key);
+
+        int leading_msgs = 0;
+
+        slotsmgrtAsyncClient *ac = getSlotsmgrtAsyncClient(c->db->id);
+        if (ac->c == c) {
+            if (ac->used == 0) {
+                ac->used = 1;
+                if (server.requirepass != NULL) {
+                    /* SLOTSRESTORE-ASYNC-AUTH $password */
+                    addReplyMultiBulkLen(c, 2);
+                    addReplyBulkCString(c, "SLOTSRESTORE-ASYNC-AUTH");
+                    addReplyBulkCString(c, server.requirepass);
+                    leading_msgs += 1;
+                }
+                do {
+                    /* SLOTSRESTORE-ASYNC-SELECT $db */
+                    addReplyMultiBulkLen(c, 2);
+                    addReplyBulkCString(c, "SLOTSRESTORE-ASYNC-SELECT");
+                    addReplyBulkLongLong(c, c->db->id);
+                    leading_msgs += 1;
+                } while (0);
+            }
+        }
+
+        /* SLOTSRESTORE-ASYNC delete $key */
+        addReplyMultiBulkLen(c, 3);
+        addReplyBulkCString(c, "SLOTSRESTORE-ASYNC");
+        addReplyBulkCString(c, "delete");
+        addReplyBulk(c, key);
+
+        long n = numberOfRestoreCommandsFromObject(val, maxbulks);
+        if (n >= 2) {
+            it->stage = STAGE_CHUNKED;
+            it->chunked_msgs = n;
+        } else {
+            it->stage = STAGE_PAYLOAD;
+            it->chunked_msgs = 0;
+        }
+        return 1 + leading_msgs;
+    }
+
+    robj *val = it->val;
+    long long ttl = 0;
+    if (it->stage == STAGE_CHUNKED) {
+        ttl = timeout * 3;
+    } else if (it->expire != -1) {
+        ttl = it->expire - mstime();
+        if (ttl < 1) {
+            ttl = 1;
+        }
+    }
+
+    if (it->stage == STAGE_FILLTTL) {
+        /* SLOTSRESTORE-ASYNC expire $key $ttl */
+        addReplyMultiBulkLen(c, 4);
+        addReplyBulkCString(c, "SLOTSRESTORE-ASYNC");
+        addReplyBulkCString(c, "expire");
+        addReplyBulk(c, key);
+        addReplyBulkLongLong(c, ttl);
+
+        it->stage = STAGE_DONE;
+        return 1;
+    }
+
+    if (it->stage == STAGE_PAYLOAD && val->type != OBJ_STRING) {
+        rio payload;
+        createDumpPayload(&payload, val);
+
+        /* SLOTSRESTORE-ASYNC object $key $ttl $payload */
+        addReplyMultiBulkLen(c, 5);
+        addReplyBulkCString(c, "SLOTSRESTORE-ASYNC");
+        addReplyBulkCString(c, "object");
+        addReplyBulk(c, key);
+        addReplyBulkLongLong(c, ttl);
+        addReplyBulkSds(c, payload.io.buffer.ptr);
+
+        it->stage = STAGE_DONE;
+        return 1;
+    }
+
+    if (it->stage == STAGE_PAYLOAD && val->type == OBJ_STRING) {
+        /* SLOTSRESTORE-ASYNC string $key $ttl $payload */
+        addReplyMultiBulkLen(c, 5);
+        addReplyBulkCString(c, "SLOTSRESTORE-ASYNC");
+        addReplyBulkCString(c, "string");
+        addReplyBulk(c, key);
+        addReplyBulkLongLong(c, ttl);
+        addReplyBulk(c, val);
+
+        it->stage = STAGE_DONE;
+        return 1;
+    }
+
+    if (it->stage == STAGE_CHUNKED) {
+        const char *cmd = NULL;
+        switch (val->type) {
+        case OBJ_LIST:
+            cmd = "list";
+            break;
+        case OBJ_HASH:
+            cmd = "hash";
+            break;
+        case OBJ_SET:
+            cmd = "dict";
+            break;
+        case OBJ_ZSET:
+            cmd = "zset";
+            break;
+        default:
+            serverPanic("unknown object type");
+        }
+
+        int more = 1;
+
+        list *ll = listCreate();
+        listSetFreeMethod(ll, decrRefCountVoid);
+        long long hint = 0, len = 0;
+
+        if (val->type == OBJ_LIST) {
+            listTypeIterator *li = listTypeInitIterator(val, it->lindex, LIST_TAIL);
+            do {
+                listTypeEntry entry;
+                if (listTypeNext(li, &entry)) {
+                    quicklistEntry *e = &(entry.entry);
+                    robj *obj;
+                    if (e->value) {
+                        obj = createStringObject((const char *)e->value, e->sz);
+                    } else {
+                        obj = createStringObjectFromLongLong(e->longval);
+                    }
+                    len += sdslenOrElse(obj, 8);
+                    listAddNodeTail(ll, obj);
+                    it->lindex ++;
+                } else {
+                    more = 0;
+                }
+            } while (more && listLength(ll) < maxbulks && len < maxbytes);
+            listTypeReleaseIterator(li);
+            hint = listTypeLength(val);
+        }
+
+        if (val->type == OBJ_HASH || val->type == OBJ_SET) {
+            int loop = maxbulks * 10;
+            if (loop < 100) {
+                loop = 100;
+            }
+            dict *ht = val->ptr;
+            void *pd[] = {ll, val, &len};
+            do {
+                it->cursor = dictScan(ht, it->cursor, singleObjectIteratorScanCallback, NULL, pd);
+                if (it->cursor == 0) {
+                    more = 0;
+                }
+            } while (more && listLength(ll) < maxbulks && len < maxbytes && (-- loop) >= 0);
+            hint = dictSize(ht);
+        }
+
+        if (val->type == OBJ_ZSET) {
+            zset *zs = val->ptr;
+            dict *ht = zs->dict;
+            long long rank = (long long)zsetLength(val) - it->zindex;
+            zskiplistNode *node = (rank >= 1) ? zslGetElementByRank(zs->zsl, rank) : NULL;
+            do {
+                if (node != NULL) {
+                    robj *field = createObject(OBJ_STRING, sdsdup(node->ele));
+                    len += sdslenOrElse(field, 8);
+                    listAddNodeTail(ll, field);
+                    uint64_t bits = convertDoubleToRawBits(node->score);
+                    robj *score = createRawStringObjectFromUint64(bits);
+                    len += sdslenOrElse(score, 8);
+                    listAddNodeTail(ll, score);
+                    node = node->backward;
+                    it->zindex ++;
+                } else {
+                    more = 0;
+                }
+            } while (more && listLength(ll) < maxbulks && len < maxbytes);
+            hint = dictSize(ht);
+        }
+
+        /* SLOTSRESTORE-ASYNC list/hash/zset/dict $key $ttl $hint [$arg1 ...] */
+        addReplyMultiBulkLen(c, 5 + listLength(ll));
+        addReplyBulkCString(c, "SLOTSRESTORE-ASYNC");
+        addReplyBulkCString(c, cmd);
+        addReplyBulk(c, key);
+        addReplyBulkLongLong(c, ttl);
+        addReplyBulkLongLong(c, hint);
+
+        while (listLength(ll) != 0) {
+            listNode *head = listFirst(ll);
+            robj *obj = listNodeValue(head);
+            addReplyBulk(c, obj);
+            listDelNode(ll, head);
+        }
+        listRelease(ll);
+
+        if (!more) {
+            it->stage = STAGE_FILLTTL;
+        }
+        return 1;
+    }
+
+    if (it->stage != STAGE_DONE) {
+        serverPanic("invalid iterator stage");
+    }
+
+    serverPanic("use of empty iterator");
+}
+
+/* ============================ Iterator for Data Migration (batched) ====================== */
+
+typedef struct {
+    struct zskiplist *tags;
+    dict *keys;
+    list *list;
+    dict *hash_slot;
+    struct zskiplist *hash_tags;
+    long long timeout;
+    unsigned int maxbulks;
+    unsigned int maxbytes;
+    list *removed_keys;
+    list *chunked_vals;
+    long estimate_msgs;
+} batchedObjectIterator;
+
+static batchedObjectIterator *
+createBatchedObjectIterator(dict *hash_slot, struct zskiplist *hash_tags,
+        long long timeout, unsigned int maxbulks, unsigned int maxbytes) {
+    batchedObjectIterator *it = zmalloc(sizeof(batchedObjectIterator));
+    it->tags = zslCreate();
+    it->keys = dictCreate(&setDictType, NULL);
+    it->list = listCreate();
+    listSetFreeMethod(it->list, freeSingleObjectIteratorVoid);
+    it->hash_slot = hash_slot;
+    it->hash_tags = hash_tags;
+    it->timeout = timeout;
+    it->maxbulks = maxbulks;
+    it->maxbytes = maxbytes;
+    it->removed_keys = listCreate();
+    listSetFreeMethod(it->removed_keys, decrRefCountVoid);
+    it->chunked_vals = listCreate();
+    listSetFreeMethod(it->chunked_vals, decrRefCountVoid);
+    it->estimate_msgs = 0;
+    return it;
+}
+
+static void
+freeBatchedObjectIterator(batchedObjectIterator *it) {
+    zslFree(it->tags);
+    dictRelease(it->keys);
+    listRelease(it->list);
+    listRelease(it->removed_keys);
+    listRelease(it->chunked_vals);
+    zfree(it);
+}
+
+static int
+batchedObjectIteratorHasNext(batchedObjectIterator *it) {
+    while (listLength(it->list) != 0) {
+        listNode *head = listFirst(it->list);
+        singleObjectIterator *sp = listNodeValue(head);
+        if (singleObjectIteratorHasNext(sp)) {
+            return 1;
+        }
+        if (sp->val != NULL) {
+            incrRefCount(sp->key);
+            listAddNodeTail(it->removed_keys, sp->key);
+            if (sp->chunked_msgs != 0) {
+                incrRefCount(sp->val);
+                listAddNodeTail(it->chunked_vals, sp->val);
+            }
+        }
+        listDelNode(it->list, head);
+    }
+    return 0;
+}
+
+static int
+batchedObjectIteratorNext(client *c, batchedObjectIterator *it) {
+    if (listLength(it->list) != 0) {
+        listNode *head = listFirst(it->list);
+        singleObjectIterator *sp = listNodeValue(head);
+        long long maxbytes = (long long)it->maxbytes - getClientOutputBufferMemoryUsage(c);
+        return singleObjectIteratorNext(c, sp, it->timeout, it->maxbulks, maxbytes > 0 ? maxbytes : 0);
+    }
+    serverPanic("use of empty iterator");
+}
+
+static int
+batchedObjectIteratorContains(batchedObjectIterator *it, robj *key, int usetag) {
+    if (dictFind(it->keys, key->ptr) != NULL) {
+        return 1;
+    }
+    if (!usetag) {
+        return 0;
+    }
+    uint32_t crc;
+    int hastag;
+    slots_num(key->ptr, &crc, &hastag);
+    if (!hastag) {
+        return 0;
+    }
+    zrangespec range;
+    range.min = (double)crc;
+    range.minex = 0;
+    range.max = (double)crc;
+    range.maxex = 0;
+    return zslFirstInRange(it->tags, &range) != NULL;
+}
+
+static int
+batchedObjectIteratorAddKey(redisDb *db, batchedObjectIterator *it, robj *key) {
+    sds keyCopy = sdsdup(key->ptr);
+    if (dictAdd(it->keys, keyCopy, NULL) != C_OK) {
+        sdsfree(keyCopy);
+        return 0;
+    }
+    incrRefCount(key);
+    listAddNodeTail(it->list, createSingleObjectIterator(key));
+    it->estimate_msgs += estimateNumberOfRestoreCommands(db, key, it->maxbulks);
+
+    int size = dictSize(it->keys);
+
+    uint32_t crc;
+    int hastag;
+    slots_num(key->ptr, &crc, &hastag);
+    if (!hastag) {
+        goto out;
+    }
+    zrangespec range;
+    range.min = (double)crc;
+    range.minex = 0;
+    range.max = (double)crc;
+    range.maxex = 0;
+    if (zslFirstInRange(it->tags, &range) != NULL) {
+        goto out;
+    }
+    zslInsert(it->tags, (double)crc, sdsdup(key->ptr));
+
+    if (it->hash_tags == NULL) {
+        goto out;
+    }
+    zskiplistNode *node = zslFirstInRange(it->hash_tags, &range);
+    while (node != NULL && node->score == (double)crc) {
+        node = node->level[0].forward;
+        keyCopy = sdsdup(node->ele);
+        if (dictAdd(it->keys, keyCopy, NULL) != C_OK) {
+            sdsfree(keyCopy);
+            continue;
+        }
+        robj *key = createObject(OBJ_STRING, sdsdup(node->ele));
+        listAddNodeTail(it->list, createSingleObjectIterator(key));
+        it->estimate_msgs += estimateNumberOfRestoreCommands(db, key, it->maxbulks);
+    }
+
+out:
+    return 1 + dictSize(it->keys) - size;
+}
+
+/* ============================ Clients ==================================================== */
+
+static slotsmgrtAsyncClient *
+getSlotsmgrtAsyncClient(int db) {
+    return &server.slotsmgrt_cached_clients[db];
+}
+
+static void
+notifySlotsmgrtAsyncClient(slotsmgrtAsyncClient *ac, const char *errmsg) {
+    batchedObjectIterator *it = ac->batched_iter;
+    list *ll = ac->blocked_list;
+    while (listLength(ll) != 0) {
+        listNode *head = listFirst(ll);
+        client *c = listNodeValue(head);
+        if (errmsg != NULL) {
+            addReplyError(c, errmsg);
+        } else if (it == NULL) {
+            addReplyError(c, "invalid iterator (NULL)");
+        } else if (it->hash_slot == NULL) {
+            addReplyLongLong(c, listLength(it->removed_keys));
+        } else {
+            addReplyMultiBulkLen(c, 2);
+            addReplyLongLong(c, listLength(it->removed_keys));
+            addReplyLongLong(c, dictSize(it->hash_slot));
+        }
+        c->slotsmgrt_flags &= ~CLIENT_SLOTSMGRT_ASYNC_NORMAL_CLIENT;
+        c->slotsmgrt_fenceq = NULL;
+        listDelNode(ll, head);
+    }
+}
+
+static void
+unlinkSlotsmgrtAsyncCachedClient(client *c, const char *errmsg) {
+    slotsmgrtAsyncClient *ac = getSlotsmgrtAsyncClient(c->db->id);
+    serverAssert(c->slotsmgrt_flags & CLIENT_SLOTSMGRT_ASYNC_CACHED_CLIENT);
+    serverAssert(ac->c == c);
+
+    notifySlotsmgrtAsyncClient(ac, errmsg);
+
+    batchedObjectIterator *it = ac->batched_iter;
+
+    long long elapsed = mstime() - ac->lastuse;
+    serverLog(LL_WARNING, "slotsmgrt_async: unlink client %s:%d (DB=%d): "
+            "sending_msgs = %ld, batched_iter = %ld, blocked_list = %ld, "
+            "timeout = %lld(ms), elapsed = %lld(ms) (%s)",
+            ac->host, ac->port, c->db->id, ac->sending_msgs,
+            it != NULL ? (long)listLength(it->list) : -1, (long)listLength(ac->blocked_list),
+            ac->timeout, elapsed, errmsg);
+
+    sdsfree(ac->host);
+    if (it != NULL) {
+        freeBatchedObjectIterator(it);
+    }
+    listRelease(ac->blocked_list);
+
+    c->slotsmgrt_flags &= ~CLIENT_SLOTSMGRT_ASYNC_CACHED_CLIENT;
+
+    memset(ac, 0, sizeof(*ac));
+}
+
+static int
+releaseSlotsmgrtAsyncClient(int db, const char *errmsg) {
+    slotsmgrtAsyncClient *ac = getSlotsmgrtAsyncClient(db);
+    if (ac->c == NULL) {
+        return 0;
+    }
+    client *c = ac->c;
+    unlinkSlotsmgrtAsyncCachedClient(c, errmsg);
+    freeClient(c);
+    return 1;
+}
+
+static int
+createSlotsmgrtAsyncClient(int db, char *host, int port, long timeout) {
+    int fd = anetTcpNonBlockConnect(server.neterr, host, port);
+    if (fd == -1) {
+        serverLog(LL_WARNING, "slotsmgrt_async: create socket %s:%d (DB=%d) failed, %s",
+                host, port, db, server.neterr);
+        return C_ERR;
+    }
+    anetEnableTcpNoDelay(server.neterr, fd);
+
+    int wait = 100;
+    if (wait > timeout) {
+        wait = timeout;
+    }
+    if ((aeWait(fd, AE_WRITABLE, wait) & AE_WRITABLE) == 0) {
+        serverLog(LL_WARNING, "slotsmgrt_async: create socket %s:%d (DB=%d) failed, io error or timeout (%d)",
+                host, port, db, wait);
+        close(fd);
+        return C_ERR;
+    }
+
+    client *c = createClient(fd);
+    if (c == NULL) {
+        serverLog(LL_WARNING, "slotsmgrt_async: create client %s:%d (DB=%d) failed, %s",
+                host, port, db, server.neterr);
+        return C_ERR;
+    }
+    if (selectDb(c, db) != C_OK) {
+        serverLog(LL_WARNING, "slotsmgrt_async: invalid DB index (DB=%d)", db);
+        freeClient(c);
+        return C_ERR;
+    }
+    c->slotsmgrt_flags |= CLIENT_SLOTSMGRT_ASYNC_CACHED_CLIENT;
+    c->authenticated = 1;
+
+    releaseSlotsmgrtAsyncClient(db, "interrupted: build new connection");
+
+    serverLog(LL_WARNING, "slotsmgrt_async: create client %s:%d (DB=%d) OK", host, port, db);
+
+    slotsmgrtAsyncClient *ac = getSlotsmgrtAsyncClient(db);
+    ac->c = c;
+    ac->used = 0;
+    ac->host = sdsnew(host);
+    ac->port = port;
+    ac->timeout = timeout;
+    ac->lastuse = mstime();
+    ac->sending_msgs = 0;
+    ac->batched_iter = NULL;
+    ac->blocked_list = listCreate();
+    return C_OK;
+}
+
+static slotsmgrtAsyncClient *
+getOrCreateSlotsmgrtAsyncClient(int db, char *host, int port, long timeout) {
+    slotsmgrtAsyncClient *ac = getSlotsmgrtAsyncClient(db);
+    if (ac->c != NULL) {
+        if (ac->port == port && !strcmp(ac->host, host)) {
+            return ac;
+        }
+    }
+    return createSlotsmgrtAsyncClient(db, host, port, timeout) != C_OK ? NULL : ac;
+}
+
+static void
+unlinkSlotsmgrtAsyncNormalClient(client *c) {
+    serverAssert(c->slotsmgrt_flags & CLIENT_SLOTSMGRT_ASYNC_NORMAL_CLIENT);
+    serverAssert(c->slotsmgrt_fenceq != NULL);
+
+    list *ll = c->slotsmgrt_fenceq;
+    listNode *node = listSearchKey(ll, c);
+    serverAssert(node != NULL);
+
+    c->slotsmgrt_flags &= ~CLIENT_SLOTSMGRT_ASYNC_NORMAL_CLIENT;
+    c->slotsmgrt_fenceq = NULL;
+    listDelNode(ll, node);
+}
+
+void
+slotsmgrtAsyncUnlinkClient(client *c) {
+    if (c->slotsmgrt_flags & CLIENT_SLOTSMGRT_ASYNC_CACHED_CLIENT) {
+        unlinkSlotsmgrtAsyncCachedClient(c, "interrupted: connection closed");
+    }
+    if (c->slotsmgrt_flags & CLIENT_SLOTSMGRT_ASYNC_NORMAL_CLIENT) {
+        unlinkSlotsmgrtAsyncNormalClient(c);
+    }
+}
+
+void
+slotsmgrtAsyncCleanup() {
+    for (int i = 0; i < server.dbnum; i ++) {
+        slotsmgrtAsyncClient *ac = getSlotsmgrtAsyncClient(i);
+        if (ac->c == NULL) {
+            continue;
+        }
+        long long elapsed = mstime() - ac->lastuse;
+        long long timeout = ac->batched_iter != NULL ? ac->timeout : 1000LL * 60;
+        if (elapsed <= timeout) {
+            continue;
+        }
+        releaseSlotsmgrtAsyncClient(i, ac->batched_iter != NULL ?
+                "interrupted: migration timeout" : "interrupted: idle timeout");
+    }
+}
+
+static int
+getSlotsmgrtAsyncClientMigrationStatusOrBlock(client *c, robj *key, int block) {
+    slotsmgrtAsyncClient *ac = getSlotsmgrtAsyncClient(c->db->id);
+    if (ac->c == NULL || ac->batched_iter == NULL) {
+        return 0;
+    }
+    batchedObjectIterator *it = ac->batched_iter;
+    if (key != NULL && !batchedObjectIteratorContains(it, key, 1)) {
+        return 0;
+    }
+    if (!block) {
+        return 1;
+    }
+    if (c->slotsmgrt_flags & CLIENT_SLOTSMGRT_ASYNC_NORMAL_CLIENT) {
+        return -1;
+    }
+    list *ll = ac->blocked_list;
+    c->slotsmgrt_flags |= CLIENT_SLOTSMGRT_ASYNC_NORMAL_CLIENT;
+    c->slotsmgrt_fenceq = ll;
+    listAddNodeTail(ll, c);
+    return 1;
+}
+
+/* ============================ Slotsmgrt{One,TagOne}AsyncDumpCommand ====================== */
+
+/* SLOTSMGRTONE-ASYNC-DUMP    $timeout $maxbulks $key1 [$key2 ...] */
+/* SLOTSMGRTTAGONE-ASYNC-DUMP $timeout $maxbulks $key1 [$key2 ...] */
+static void
+slotsmgrtAsyncDumpGenericCommand(client *c, int usetag) {
+    long long timeout;
+    if (getLongLongFromObject(c->argv[1], &timeout) != C_OK ||
+            !(timeout >= 0 && timeout <= INT_MAX)) {
+        addReplyErrorFormat(c, "invalid value of timeout (%s)",
+                (char *)c->argv[1]->ptr);
+        return;
+    }
+    if (timeout == 0) {
+        timeout = 1000 * 30;
+    }
+    long long maxbulks;
+    if (getLongLongFromObject(c->argv[2], &maxbulks) != C_OK ||
+            !(maxbulks >= 0 && maxbulks <= INT_MAX)) {
+        addReplyErrorFormat(c, "invalid value of maxbulks (%s)",
+                (char *)c->argv[2]->ptr);
+        return;
+    }
+    if (maxbulks == 0) {
+        maxbulks = 1000;
+    }
+
+    batchedObjectIterator *it = createBatchedObjectIterator(NULL,
+            usetag ? c->db->tagged_keys : NULL, timeout, maxbulks, INT_MAX);
+    for (int i = 3; i < c->argc; i ++) {
+        batchedObjectIteratorAddKey(c->db, it, c->argv[i]);
+    }
+
+    void *ptr = addDeferredMultiBulkLength(c);
+    int total = 0;
+    while (batchedObjectIteratorHasNext(it)) {
+        total += batchedObjectIteratorNext(c, it);
+    }
+    setDeferredMultiBulkLength(c, ptr, total);
+    freeBatchedObjectIterator(it);
+}
+
+/* *
+ * SLOTSMGRTONE-ASYNC-DUMP    $timeout $maxbulks $key1 [$key2 ...]
+ * */
+void slotsmgrtOneAsyncDumpCommand(client *c) {
+    if (c->argc <= 3) {
+        addReplyError(c, "wrong number of arguments for SLOTSMGRTONE-ASYNC-DUMP");
+        return;
+    }
+    slotsmgrtAsyncDumpGenericCommand(c, 0);
+}
+
+/* *
+ * SLOTSMGRTTAGONE-ASYNC-DUMP $timeout $maxbulks $key1 [$key2 ...]
+ * */
+void
+slotsmgrtTagOneAsyncDumpCommand(client *c) {
+    if (c->argc <= 3) {
+        addReplyError(c, "wrong number of arguments for SLOTSMGRTTAGONE-ASYNC-DUMP");
+        return;
+    }
+    slotsmgrtAsyncDumpGenericCommand(c, 1);
+}
+
+/* ============================ Slotsmgrt{One,TagOne,Slot,TagSlot}AsyncCommand ============= */
+
+static unsigned int
+slotsmgrtAsyncMaxBufferLimit(unsigned int maxbytes) {
+    clientBufferLimitsConfig *config = &server.client_obuf_limits[CLIENT_TYPE_NORMAL];
+    if (config->soft_limit_bytes != 0 && config->soft_limit_bytes < maxbytes) {
+        maxbytes = config->soft_limit_bytes;
+    }
+    if (config->hard_limit_bytes != 0 && config->hard_limit_bytes < maxbytes) {
+        maxbytes = config->hard_limit_bytes;
+    }
+    return maxbytes;
+}
+
+static long
+slotsmgrtAsyncNextMessagesMicroseconds(slotsmgrtAsyncClient *ac, long atleast, long long usecs) {
+    batchedObjectIterator *it = ac->batched_iter;
+    long long deadline = ustime() + usecs;
+    long msgs = 0;
+    while (batchedObjectIteratorHasNext(it) && getClientOutputBufferMemoryUsage(ac->c) < it->maxbytes) {
+        if ((msgs += batchedObjectIteratorNext(ac->c, it)) < atleast) {
+            continue;
+        }
+        if (ustime() >= deadline) {
+            return msgs;
+        }
+    }
+    return msgs;
+}
+
+static void
+slotsScanSdsKeyCallback(void *l, const dictEntry *de) {
+    sds skey = dictGetKey(de);
+    robj *key = createStringObject(skey, sdslen(skey));
+    listAddNodeTail((list *)l, key);
+}
+
+/* SLOTSMGRTONE-ASYNC     $host $port $timeout $maxbulks $maxbytes $key1 [$key2 ...] */
+/* SLOTSMGRTTAGONE-ASYNC  $host $port $timeout $maxbulks $maxbytes $key1 [$key2 ...] */
+/* SLOTSMGRTSLOT-ASYNC    $host $port $timeout $maxbulks $maxbytes $slot $numkeys    */
+/* SLOTSMGRTTAGSLOT-ASYNC $host $port $timeout $maxbulks $maxbytes $slot $numkeys    */
+static void
+slotsmgrtAsyncGenericCommand(client *c, int usetag, int usekey) {
+    char *host = c->argv[1]->ptr;
+    long long port;
+    if (getLongLongFromObject(c->argv[2], &port) != C_OK ||
+            !(port >= 1 && port < 65536)) {
+        addReplyErrorFormat(c, "invalid value of port (%s)",
+                (char *)c->argv[2]->ptr);
+        return;
+    }
+    long long timeout;
+    if (getLongLongFromObject(c->argv[3], &timeout) != C_OK ||
+            !(timeout >= 0 && timeout <= INT_MAX)) {
+        addReplyErrorFormat(c, "invalid value of timeout (%s)",
+                (char *)c->argv[3]->ptr);
+        return;
+    }
+    if (timeout == 0) {
+        timeout = 1000 * 30;
+    }
+    long long maxbulks;
+    if (getLongLongFromObject(c->argv[4], &maxbulks) != C_OK ||
+            !(maxbulks >= 0 && maxbulks <= INT_MAX)) {
+        addReplyErrorFormat(c, "invalid value of maxbulks (%s)",
+                (char *)c->argv[4]->ptr);
+        return;
+    }
+    if (maxbulks == 0) {
+        maxbulks = 200;
+    }
+    if (maxbulks > 512 * 1024) {
+        maxbulks = 512 * 1024;
+    }
+    long long maxbytes;
+    if (getLongLongFromObject(c->argv[5], &maxbytes) != C_OK ||
+            !(maxbytes >= 0 && maxbytes <= INT_MAX)) {
+        addReplyErrorFormat(c, "invalid value of maxbytes (%s)",
+                (char *)c->argv[5]->ptr);
+        return;
+    }
+    if (maxbytes == 0) {
+        maxbytes = 512 * 1024;
+    }
+    if (maxbytes > INT_MAX / 2) {
+        maxbytes = INT_MAX / 2;
+    }
+    maxbytes = slotsmgrtAsyncMaxBufferLimit(maxbytes);
+
+    dict *hash_slot = NULL;
+    long long numkeys = 0;
+    if (!usekey) {
+        long long slotnum;
+        if (getLongLongFromObject(c->argv[6], &slotnum) != C_OK ||
+                !(slotnum >= 0 && slotnum < HASH_SLOTS_SIZE)) {
+            addReplyErrorFormat(c, "invalid value of slot (%s)",
+                    (char *)c->argv[6]->ptr);
+            return;
+        }
+        hash_slot = c->db->hash_slots[slotnum];
+        if (getLongLongFromObject(c->argv[7], &numkeys) != C_OK ||
+                !(numkeys >= 0 && numkeys <= INT_MAX)) {
+            addReplyErrorFormat(c, "invalid value of numkeys (%s)",
+                    (char *)c->argv[7]->ptr);
+            return;
+        }
+        if (numkeys == 0) {
+            numkeys = 100;
+        }
+    }
+
+    if (getSlotsmgrtAsyncClientMigrationStatusOrBlock(c, NULL, 0) != 0) {
+        addReplyError(c, "the specified DB is being migrated");
+        return;
+    }
+    if (c->slotsmgrt_flags & CLIENT_SLOTSMGRT_ASYNC_NORMAL_CLIENT) {
+        addReplyError(c, "previous operation has not finished");
+        return;
+    }
+
+    slotsmgrtAsyncClient *ac = getOrCreateSlotsmgrtAsyncClient(c->db->id, host, port, timeout);
+    if (ac == NULL) {
+        addReplyErrorFormat(c, "create client to %s:%d failed", host, (int)port);
+        return;
+    }
+
+    batchedObjectIterator *it = createBatchedObjectIterator(hash_slot,
+            usetag ? c->db->tagged_keys : NULL, timeout, maxbulks, maxbytes);
+    if (!usekey) {
+        list *ll = listCreate();
+        listSetFreeMethod(ll, decrRefCountVoid);
+        for (int i = 2; i >= 0 && it->estimate_msgs < numkeys; i --) {
+            unsigned long cursor = 0;
+            if (i != 0) {
+                cursor = random();
+            } else {
+                if (htNeedsResize(hash_slot)) {
+                    dictResize(hash_slot);
+                }
+            }
+            if (dictIsRehashing(hash_slot)) {
+                dictRehash(hash_slot, 50);
+            }
+            int loop = numkeys * 10;
+            if (loop < 100) {
+                loop = 100;
+            }
+            do {
+                cursor = dictScan(hash_slot, cursor, slotsScanSdsKeyCallback, NULL, ll);
+                while (listLength(ll) != 0 && it->estimate_msgs < numkeys) {
+                    listNode *head = listFirst(ll);
+                    robj *key = listNodeValue(head);
+                    long msgs = estimateNumberOfRestoreCommands(c->db, key, it->maxbulks);
+                    if (it->estimate_msgs == 0 || it->estimate_msgs + msgs <= numkeys * 2) {
+                        batchedObjectIteratorAddKey(c->db, it, key);
+                    }
+                    listDelNode(ll, head);
+                }
+            } while (cursor != 0 && it->estimate_msgs < numkeys &&
+                    dictSize(it->keys) < (unsigned long)numkeys && (-- loop) >= 0);
+        }
+        listRelease(ll);
+    } else {
+        for (int i = 6; i < c->argc; i ++) {
+            batchedObjectIteratorAddKey(c->db, it, c->argv[i]);
+        }
+    }
+    serverAssert(ac->sending_msgs == 0);
+    serverAssert(ac->batched_iter == NULL && listLength(ac->blocked_list) == 0);
+
+    ac->timeout = timeout;
+    ac->lastuse = mstime();
+    ac->batched_iter = it;
+    ac->sending_msgs = slotsmgrtAsyncNextMessagesMicroseconds(ac, 3, 500);
+
+    getSlotsmgrtAsyncClientMigrationStatusOrBlock(c, NULL, 1);
+
+    if (ac->sending_msgs != 0) {
+        return;
+    }
+    notifySlotsmgrtAsyncClient(ac, NULL);
+
+    ac->batched_iter = NULL;
+    freeBatchedObjectIterator(it);
+}
+
+/* *
+ * SLOTSMGRTONE-ASYNC     $host $port $timeout $maxbulks $maxbytes $key1 [$key2 ...]
+ * */
+void slotsmgrtOneAsyncCommand(client *c) {
+    if (c->argc <= 6) {
+        addReplyError(c, "wrong number of arguments for SLOTSMGRTONE-ASYNC");
+        return;
+    }
+    slotsmgrtAsyncGenericCommand(c, 0, 1);
+}
+
+/* *
+ * SLOTSMGRTTAGONE-ASYNC  $host $port $timeout $maxbulks $maxbytes $key1 [$key2 ...]
+ * */
+void slotsmgrtTagOneAsyncCommand(client *c) {
+    if (c->argc <= 6) {
+        addReplyError(c, "wrong number of arguments for SLOTSMGRTTAGONE-ASYNC");
+        return;
+    }
+    slotsmgrtAsyncGenericCommand(c, 1, 1);
+}
+
+/* *
+ * SLOTSMGRTSLOT-ASYNC    $host $port $timeout $maxbulks $maxbytes $slot $numkeys
+ * */
+void slotsmgrtSlotAsyncCommand(client *c) {
+    if (c->argc != 8) {
+        addReplyError(c, "wrong number of arguments for SLOTSMGRTSLOT-ASYNC");
+        return;
+    }
+    slotsmgrtAsyncGenericCommand(c, 0, 0);
+}
+
+/* *
+ * SLOTSMGRTTAGSLOT-ASYNC $host $port $timeout $maxbulks $maxbytes $slot $numkeys
+ * */
+void slotsmgrtTagSlotAsyncCommand(client *c) {
+    if (c->argc != 8) {
+        addReplyError(c, "wrong number of arguments for SLOTSMGRTSLOT-ASYNC");
+        return;
+    }
+    slotsmgrtAsyncGenericCommand(c, 1, 0);
+}
+
+/* *
+ * SLOTSMGRT-ASYNC-FENCE
+ * */
+void
+slotsmgrtAsyncFenceCommand(client *c) {
+    int ret = getSlotsmgrtAsyncClientMigrationStatusOrBlock(c, NULL, 1);
+    if (ret == 0) {
+        addReply(c, shared.ok);
+    } else if (ret != 1) {
+        addReplyError(c, "previous operation has not finished (call fence again)");
+    }
+}
+
+/* *
+ * SLOTSMGRT-ASYNC-CANCEL
+ * */
+void
+slotsmgrtAsyncCancelCommand(client *c) {
+    addReplyLongLong(c, releaseSlotsmgrtAsyncClient(c->db->id, "interrupted: canceled"));
+}
+
+/* ============================ SlotsmgrtAsyncStatus ======================================= */
+
+static void
+singleObjectIteratorStatus(client *c, singleObjectIterator *it) {
+    if (it == NULL) {
+        addReply(c, shared.nullmultibulk);
+        return;
+    }
+    void *ptr = addDeferredMultiBulkLength(c);
+    int fields = 0;
+
+    fields ++; addReplyBulkCString(c, "key");
+    addReplyBulk(c, it->key);
+
+    fields ++; addReplyBulkCString(c, "val.type");
+    addReplyBulkLongLong(c, it->val == NULL ? -1 : it->val->type);
+
+    fields ++; addReplyBulkCString(c, "stage");
+    addReplyBulkLongLong(c, it->stage);
+
+    fields ++; addReplyBulkCString(c, "expire");
+    addReplyBulkLongLong(c, it->expire);
+
+    fields ++; addReplyBulkCString(c, "cursor");
+    addReplyBulkLongLong(c, it->cursor);
+
+    fields ++; addReplyBulkCString(c, "lindex");
+    addReplyBulkLongLong(c, it->lindex);
+
+    fields ++; addReplyBulkCString(c, "zindex");
+    addReplyBulkLongLong(c, it->zindex);
+
+    fields ++; addReplyBulkCString(c, "chunked_msgs");
+    addReplyBulkLongLong(c, it->chunked_msgs);
+
+    setDeferredMultiBulkLength(c, ptr, fields * 2);
+}
+
+static void
+batchedObjectIteratorStatus(client *c, batchedObjectIterator *it) {
+    if (it == NULL) {
+        addReply(c, shared.nullmultibulk);
+        return;
+    }
+    void *ptr = addDeferredMultiBulkLength(c);
+    int fields = 0;
+
+    fields ++; addReplyBulkCString(c, "keys");
+    addReplyMultiBulkLen(c, 2);
+    addReplyBulkLongLong(c, dictSize(it->keys));
+    addReplyMultiBulkLen(c, dictSize(it->keys));
+    dictIterator *di = dictGetIterator(it->keys);
+    dictEntry *de;
+    while((de = dictNext(di)) != NULL) {
+        addReplyBulk(c, dictGetKey(de));
+    }
+    dictReleaseIterator(di);
+
+    fields ++; addReplyBulkCString(c, "timeout");
+    addReplyBulkLongLong(c, it->timeout);
+
+    fields ++; addReplyBulkCString(c, "maxbulks");
+    addReplyBulkLongLong(c, it->maxbulks);
+
+    fields ++; addReplyBulkCString(c, "maxbytes");
+    addReplyBulkLongLong(c, it->maxbytes);
+
+    fields ++; addReplyBulkCString(c, "estimate_msgs");
+    addReplyBulkLongLong(c, it->estimate_msgs);
+
+    fields ++; addReplyBulkCString(c, "removed_keys");
+    addReplyBulkLongLong(c, listLength(it->removed_keys));
+
+    fields ++; addReplyBulkCString(c, "chunked_vals");
+    addReplyBulkLongLong(c, listLength(it->chunked_vals));
+
+    fields ++; addReplyBulkCString(c, "iterators");
+    addReplyMultiBulkLen(c, 2);
+    addReplyBulkLongLong(c, listLength(it->list));
+    singleObjectIterator *sp = NULL;
+    if (listLength(it->list) != 0) {
+        sp = listNodeValue(listFirst(it->list));
+    }
+    singleObjectIteratorStatus(c, sp);
+
+    setDeferredMultiBulkLength(c, ptr, fields * 2);
+}
+
+/* *
+ * SLOTSMGRT-ASYNC-STATUS
+ * */
+void
+slotsmgrtAsyncStatusCommand(client *c) {
+    slotsmgrtAsyncClient *ac = getSlotsmgrtAsyncClient(c->db->id);
+    if (ac->c == NULL) {
+        addReply(c, shared.nullmultibulk);
+        return;
+    }
+    void *ptr = addDeferredMultiBulkLength(c);
+    int fields = 0;
+
+    fields ++; addReplyBulkCString(c, "host");
+    addReplyBulkCString(c, ac->host);
+
+    fields ++; addReplyBulkCString(c, "port");
+    addReplyBulkLongLong(c, ac->port);
+
+    fields ++; addReplyBulkCString(c, "used");
+    addReplyBulkLongLong(c, ac->used);
+
+    fields ++; addReplyBulkCString(c, "timeout");
+    addReplyBulkLongLong(c, ac->timeout);
+
+    fields ++; addReplyBulkCString(c, "lastuse");
+    addReplyBulkLongLong(c, ac->lastuse);
+
+    fields ++; addReplyBulkCString(c, "since_lastuse");
+    addReplyBulkLongLong(c, mstime() - ac->lastuse);
+
+    fields ++; addReplyBulkCString(c, "sending_msgs");
+    addReplyBulkLongLong(c, ac->sending_msgs);
+
+    fields ++; addReplyBulkCString(c, "blocked_clients");
+    addReplyBulkLongLong(c, listLength(ac->blocked_list));
+
+    fields ++; addReplyBulkCString(c, "batched_iterator");
+    batchedObjectIteratorStatus(c, ac->batched_iter);
+
+    setDeferredMultiBulkLength(c, ptr, fields * 2);
+}
+
+/* ============================ SlotsmgrtExecWrapper ======================================= */
+
+/* *
+ * SLOTSMGRT-EXEC-WRAPPER $hashkey $command [$arg1 ...]
+ * */
+void
+slotsmgrtExecWrapperCommand(client *c) {
+    addReplyMultiBulkLen(c, 2);
+    if (c->argc < 3) {
+        addReplyLongLong(c, -1);
+        addReplyError(c, "wrong number of arguments for SLOTSMGRT-EXEC-WRAPPER");
+        return;
+    }
+    struct redisCommand *cmd = lookupCommand(c->argv[2]->ptr);
+    if (cmd == NULL) {
+        addReplyLongLong(c, -1);
+        addReplyErrorFormat(c,"invalid command specified (%s)",
+                (char *)c->argv[2]->ptr);
+        return;
+    }
+    if ((cmd->arity > 0 && cmd->arity != c->argc - 2) || (c->argc - 2 < -cmd->arity)) {
+        addReplyLongLong(c, -1);
+        addReplyErrorFormat(c, "wrong number of arguments for command (%s)",
+                (char *)c->argv[2]->ptr);
+        return;
+    }
+    if (lookupKeyWrite(c->db, c->argv[1]) == NULL) {
+        addReplyLongLong(c, 0);
+        addReplyError(c, "the specified key doesn't exist");
+        return;
+    }
+    if (!(cmd->flags & CMD_READONLY) && getSlotsmgrtAsyncClientMigrationStatusOrBlock(c, c->argv[1], 0) != 0) {
+        addReplyLongLong(c, 1);
+        addReplyError(c, "the specified key is being migrated");
+        return;
+    } else {
+        addReplyLongLong(c, 2);
+        robj **argv = zmalloc(sizeof(robj *) * (c->argc - 2));
+        for (int i = 2; i < c->argc; i ++) {
+            argv[i - 2] = c->argv[i];
+            incrRefCount(c->argv[i]);
+        }
+        for (int i = 0; i < c->argc; i ++) {
+            decrRefCount(c->argv[i]);
+        }
+        zfree(c->argv);
+        c->argc = c->argc - 2;
+        c->argv = argv;
+        c->cmd = cmd;
+        call(c, CMD_CALL_FULL & ~CMD_CALL_PROPAGATE);
+    }
+}
+
+/* ============================ SlotsrestoreAsync Commands ================================= */
+
+static void
+slotsrestoreReplyAck(client *c, int err_code, const char *fmt, ...) {
+    va_list ap;
+    va_start(ap, fmt);
+    sds s = sdscatvprintf(sdsempty(), fmt, ap);
+    va_end(ap);
+
+    addReplyMultiBulkLen(c, 3);
+    addReplyBulkCString(c, "SLOTSRESTORE-ASYNC-ACK");
+    addReplyBulkLongLong(c, err_code);
+    addReplyBulkSds(c, s);
+
+    if (err_code != 0) {
+        c->flags |= CLIENT_CLOSE_AFTER_REPLY;
+    }
+}
+
+extern int verifyDumpPayload(unsigned char *p, size_t len);
+
+static int
+slotsrestoreAsyncHandle(client *c) {
+    if (getSlotsmgrtAsyncClientMigrationStatusOrBlock(c, NULL, 0) != 0) {
+        slotsrestoreReplyAck(c, -1, "the specified DB is being migrated");
+        return C_ERR;
+    }
+
+    const char *cmd = "";
+    if (c->argc < 2) {
+        goto bad_arguments_number;
+    }
+    cmd = c->argv[1]->ptr;
+
+    /* ==================================================== */
+    /* SLOTSRESTORE-ASYNC $cmd $key [$ttl $arg1, $arg2 ...] */
+    /* ==================================================== */
+
+    if (c->argc < 3) {
+        goto bad_arguments_number;
+    }
+
+    robj *key = c->argv[2];
+
+    /* SLOTSRESTORE-ASYNC delete $key */
+    if (!strcasecmp(cmd, "delete")) {
+        if (c->argc != 3) {
+            goto bad_arguments_number;
+        }
+        int deleted = dbDelete(c->db, key);
+        if (deleted) {
+            signalModifiedKey(c->db, key);
+            server.dirty ++;
+        }
+        slotsrestoreReplyAck(c, 0, deleted ? "1" : "0");
+        return C_OK;
+    }
+
+    /* ==================================================== */
+    /* SLOTSRESTORE-ASYNC $cmd $key $ttl [$arg1, $arg2 ...] */
+    /* ==================================================== */
+
+    if (c->argc < 4) {
+        goto bad_arguments_number;
+    }
+
+    long long ttl;
+    if (getLongLongFromObject(c->argv[3], &ttl) != C_OK || ttl < 0) {
+        slotsrestoreReplyAck(c, -1, "invalid TTL value (TTL=%s)", c->argv[3]->ptr);
+        return C_ERR;
+    }
+
+    /* SLOTSRESTORE-ASYNC expire $key $ttl */
+    if (!strcasecmp(cmd, "expire")) {
+        if (c->argc != 4) {
+            goto bad_arguments_number;
+        }
+        if (lookupKeyWrite(c->db, key) == NULL) {
+            slotsrestoreReplyAck(c, -1, "the specified key doesn't exist (%s)", key->ptr);
+            return C_ERR;
+        }
+        slotsrestoreReplyAck(c, 0, "1");
+        goto success_common;
+    }
+
+    /* SLOTSRESTORE-ASYNC string $key $ttl $payload */
+    if (!strcasecmp(cmd, "string")) {
+        if (c->argc != 5) {
+            goto bad_arguments_number;
+        }
+        if (lookupKeyWrite(c->db, key) != NULL) {
+            slotsrestoreReplyAck(c, -1, "the specified key already exists (%s)", key->ptr);
+            return C_ERR;
+        }
+        robj *val = c->argv[4] = tryObjectEncoding(c->argv[4]);
+        dbAdd(c->db, key, val);
+        incrRefCount(val);
+        slotsrestoreReplyAck(c, 0, "1");
+        goto success_common;
+    }
+
+    /* SLOTSRESTORE-ASYNC object $key $ttl $payload */
+    if (!strcasecmp(cmd, "object")) {
+        if (c->argc != 5) {
+            goto bad_arguments_number;
+        }
+        if (lookupKeyWrite(c->db, key) != NULL) {
+            slotsrestoreReplyAck(c, -1, "the specified key already exists (%s)", key->ptr);
+            return C_ERR;
+        }
+        void *bytes = c->argv[4]->ptr;
+        rio payload;
+        if (verifyDumpPayload(bytes, sdslen(bytes)) != C_OK) {
+            slotsrestoreReplyAck(c, -1, "invalid payload checksum");
+            return C_ERR;
+        }
+        rioInitWithBuffer(&payload, bytes);
+        int type = rdbLoadObjectType(&payload);
+        if (type == -1) {
+            slotsrestoreReplyAck(c, -1, "invalid payload type");
+            return C_ERR;
+        }
+        robj *val = rdbLoadObject(type, &payload);
+        if (val == NULL) {
+            slotsrestoreReplyAck(c, -1, "invalid payload body");
+            return C_ERR;
+        }
+        dbAdd(c->db, key, val);
+        slotsrestoreReplyAck(c, 0, "1");
+        goto success_common;
+    }
+
+    /* ========================================================== */
+    /* SLOTSRESTORE-ASYNC $cmd $key $ttl $hint [$arg1, $arg2 ...] */
+    /* ========================================================== */
+
+    if (c->argc < 5) {
+        goto bad_arguments_number;
+    }
+
+    long long hint;
+    if (getLongLongFromObject(c->argv[4], &hint) != C_OK || hint < 0) {
+        slotsrestoreReplyAck(c, -1, "invalid Hint value (Hint=%s)", c->argv[4]->ptr);
+        return C_ERR;
+    }
+
+    int xargc = c->argc - 5;
+    robj **xargv = &c->argv[5];
+
+    /* SLOTSRESTORE-ASYNC list $key $ttl $hint [$elem1 ...] */
+    if (!strcasecmp(cmd, "list")) {
+        robj *val = lookupKeyWrite(c->db, key);
+        if (val != NULL) {
+            if (val->type != OBJ_LIST || val->encoding != OBJ_ENCODING_QUICKLIST) {
+                slotsrestoreReplyAck(c, -1, "wrong type (expect=%d/%d,got=%d/%d)",
+                        OBJ_LIST, OBJ_ENCODING_QUICKLIST, val->type, val->encoding);
+                return C_ERR;
+            }
+        } else {
+            if (xargc == 0) {
+                slotsrestoreReplyAck(c, -1, "the specified key doesn't exist (%s)", key->ptr);
+                return C_ERR;
+            }
+            val = createQuicklistObject();
+            quicklistSetOptions(val->ptr, server.list_max_ziplist_size,
+                    server.list_compress_depth);
+            dbAdd(c->db, key, val);
+        }
+        for (int i = 0; i < xargc; i ++) {
+            xargv[i] = tryObjectEncoding(xargv[i]);
+            listTypePush(val, xargv[i], LIST_TAIL);
+        }
+        slotsrestoreReplyAck(c, 0, "%d", listTypeLength(val));
+        goto success_common;
+    }
+
+    /* SLOTSRESTORE-ASYNC hash $key $ttl $hint [$hkey1 $hval1 ...] */
+    if (!strcasecmp(cmd, "hash")) {
+        if (xargc % 2 != 0) {
+            goto bad_arguments_number;
+        }
+        robj *val = lookupKeyWrite(c->db, key);
+        if (val != NULL) {
+            if (val->type != OBJ_HASH || val->encoding != OBJ_ENCODING_HT) {
+                slotsrestoreReplyAck(c, -1, "wrong type (expect=%d/%d,got=%d/%d)",
+                        OBJ_HASH, OBJ_ENCODING_HT, val->type, val->encoding);
+                return C_ERR;
+            }
+        } else {
+            if (xargc == 0) {
+                slotsrestoreReplyAck(c, -1, "the specified key doesn't exist (%s)", key->ptr);
+                return C_ERR;
+            }
+            val = createHashObject();
+            if (val->encoding !=  OBJ_ENCODING_HT) {
+                hashTypeConvert(val, OBJ_ENCODING_HT);
+            }
+            dbAdd(c->db, key, val);
+        }
+        if (hint != 0) {
+            dict *ht = val->ptr;
+            dictExpand(ht, hint);
+        }
+        for (int i = 0; i < xargc; i += 2) {
+            hashTypeTryObjectEncoding(val, &xargv[i], &xargv[i + 1]);
+            hashTypeSet(val, xargv[i]->ptr, xargv[i + 1]->ptr, HASH_SET_COPY);
+        }
+        slotsrestoreReplyAck(c, 0, "%d", hashTypeLength(val));
+        goto success_common;
+    }
+
+    /* SLOTSRESTORE-ASYNC dict $key $ttl $hint [$elem1 ...] */
+    if (!strcasecmp(cmd, "dict")) {
+        robj *val = lookupKeyWrite(c->db, key);
+        if (val != NULL) {
+            if (val->type != OBJ_SET || val->encoding != OBJ_ENCODING_HT) {
+                slotsrestoreReplyAck(c, -1, "wrong type (expect=%d/%d,got=%d/%d)",
+                        OBJ_SET, OBJ_ENCODING_HT, val->type, val->encoding);
+                return C_ERR;
+            }
+        } else {
+            if (xargc == 0) {
+                slotsrestoreReplyAck(c, -1, "the specified key doesn't exist (%s)", key->ptr);
+                return C_ERR;
+            }
+            val = createSetObject();
+            if (val->encoding != OBJ_ENCODING_HT) {
+                setTypeConvert(val, OBJ_ENCODING_HT);
+            }
+            dbAdd(c->db, key, val);
+        }
+        if (hint != 0) {
+            dict *ht = val->ptr;
+            dictExpand(ht, hint);
+        }
+        for (int i = 0; i < xargc; i ++) {
+            xargv[i] = tryObjectEncoding(xargv[i]);
+            setTypeAdd(val, xargv[i]->ptr);
+        }
+        slotsrestoreReplyAck(c, 0, "%d", setTypeSize(val));
+        goto success_common;
+    }
+
+    /* SLOTSRESTORE-ASYNC zset $key $ttl $hint [$elem1 $score1 ...] */
+    if (!strcasecmp(cmd, "zset")) {
+        if (xargc % 2 != 0) {
+            goto bad_arguments_number;
+        }
+        double *scores = zmalloc(sizeof(double) * xargc / 2);
+        for (int i = 1, j = 0; i < xargc; i += 2, j ++) {
+            uint64_t bits;
+            if (getUint64FromRawStringObject(xargv[i], &bits) != C_OK) {
+                zfree(scores);
+                slotsrestoreReplyAck(c, -1, "invalid zset score ([%d]), bad raw bits", j);
+                return C_ERR;
+            }
+            scores[j] = convertRawBitsToDouble(bits);
+        }
+        robj *val = lookupKeyWrite(c->db, key);
+        if (val != NULL) {
+            if (val->type != OBJ_ZSET || val->encoding != OBJ_ENCODING_SKIPLIST) {
+                zfree(scores);
+                slotsrestoreReplyAck(c, -1, "wrong type (expect=%d/%d,got=%d/%d)",
+                        OBJ_ZSET, OBJ_ENCODING_SKIPLIST, val->type, val->encoding);
+                return C_ERR;
+            }
+        } else {
+            if (xargc == 0) {
+                zfree(scores);
+                slotsrestoreReplyAck(c, -1, "the specified key doesn't exist (%s)", key->ptr);
+                return C_ERR;
+            }
+            val = createZsetObject();
+            if (val->encoding != OBJ_ENCODING_SKIPLIST) {
+                zsetConvert(val, OBJ_ENCODING_SKIPLIST);
+            }
+            dbAdd(c->db, key, val);
+        }
+        zset *zset = val->ptr;
+        if (hint != 0) {
+            dict *ht = zset->dict;
+            dictExpand(ht, hint);
+        }
+        for (int i = 0, j = 0; i < xargc; i += 2, j ++) {
+            robj *elem = xargv[i] = tryObjectEncoding(xargv[i]);
+            dictEntry *de = dictFind(zset->dict, elem->ptr);
+            if (de != NULL) {
+                double score = *(double *)dictGetVal(de);
+                zslDelete(zset->zsl, score, elem->ptr, NULL);
+                dictDelete(zset->dict, elem->ptr);
+            }
+            zskiplistNode *znode = zslInsert(zset->zsl, scores[j], sdsdup(elem->ptr));
+            dictAdd(zset->dict, sdsdup(elem->ptr), &(znode->score));
+        }
+        zfree(scores);
+        slotsrestoreReplyAck(c, 0, "%d", zsetLength(val));
+        goto success_common;
+    }
+
+    slotsrestoreReplyAck(c, -1, "unknown command (argc=%d,cmd=%s)", c->argc, cmd);
+    return C_ERR;
+
+bad_arguments_number:
+    slotsrestoreReplyAck(c, -1, "wrong number of arguments (argc=%d,cmd=%s)", c->argc, cmd);
+    return C_ERR;
+
+success_common:
+    if (ttl != 0) {
+        setExpire(c, c->db, key, mstime() + ttl);
+    } else {
+        removeExpire(c->db, key);
+    }
+    signalModifiedKey(c->db, key);
+    server.dirty ++;
+    return C_OK;
+}
+
+
+/* *
+ * SLOTSRESTORE-ASYNC delete $key
+ *                    expire $key $ttl
+ *                    object $key $ttl $payload
+ *                    string $key $ttl $payload
+ *                    list   $key $ttl $hint [$elem1 ...]
+ *                    hash   $key $ttl $hint [$hkey1 $hval1 ...]
+ *                    dict   $key $ttl $hint [$elem1 ...]
+ *                    zset   $key $ttl $hint [$elem1 $score1 ...]
+ * */
+void
+slotsrestoreAsyncCommand(client *c) {
+    if (slotsrestoreAsyncHandle(c) != C_OK) {
+        c->flags |= CLIENT_CLOSE_AFTER_REPLY;
+    }
+}
+
+static int
+slotsrestoreAsyncAckHandle(client *c) {
+    slotsmgrtAsyncClient *ac = getSlotsmgrtAsyncClient(c->db->id);
+    if (ac->c != c) {
+        addReplyErrorFormat(c, "invalid client, permission denied");
+        return C_ERR;
+    }
+    if (c->argc != 3) {
+        addReplyError(c, "wrong number of arguments for SLOTSRESTORE-ASYNC-ACK");
+        return C_ERR;
+    }
+    long long errcode;
+    if (getLongLongFromObject(c->argv[1], &errcode) != C_OK) {
+        addReplyErrorFormat(c, "invalid errcode (%s)",
+                (char *)c->argv[1]->ptr);
+        return C_ERR;
+    }
+    const char *errmsg = c->argv[2]->ptr;
+    if (errcode != 0) {
+        serverLog(LL_WARNING, "slotsmgrt_async: ack[%d] %s",
+                (int)errcode, errmsg != NULL ? errmsg : "(null)");
+        return C_ERR;
+    }
+    if (ac->batched_iter == NULL) {
+        serverLog(LL_WARNING, "slotsmgrt_async: null batched iterator");
+        addReplyError(c, "invalid iterator (NULL)");
+        return C_ERR;
+    }
+    if (ac->sending_msgs == 0) {
+        serverLog(LL_WARNING, "slotsmgrt_async: invalid message counter");
+        addReplyError(c, "invalid pending messages");
+        return C_ERR;
+    }
+
+    ac->lastuse = mstime();
+    ac->sending_msgs -= 1;
+    ac->sending_msgs += slotsmgrtAsyncNextMessagesMicroseconds(ac, 2, 10);
+
+    if (ac->sending_msgs != 0) {
+        return C_OK;
+    }
+    notifySlotsmgrtAsyncClient(ac, NULL);
+
+    batchedObjectIterator *it = ac->batched_iter;
+    if (listLength(it->removed_keys) != 0) {
+        list *ll = it->removed_keys;
+        for (int i = 0; i < c->argc; i ++) {
+            decrRefCount(c->argv[i]);
+        }
+        zfree(c->argv);
+        c->argc = 1 + listLength(ll);
+        c->argv = zmalloc(sizeof(robj *) * c->argc);
+        for (int i = 1; i < c->argc; i ++) {
+            listNode *head = listFirst(ll);
+            robj *key = listNodeValue(head);
+            if (dbDelete(c->db, key)) {
+                signalModifiedKey(c->db, key);
+                server.dirty ++;
+            }
+            c->argv[i] = key;
+            incrRefCount(key);
+            listDelNode(ll, head);
+        }
+        c->argv[0] = createStringObject("DEL", 3);
+    }
+
+    if (listLength(it->chunked_vals) != 0) {
+        list *ll = it->chunked_vals;
+        while (listLength(ll) != 0) {
+            listNode *head = listFirst(ll);
+            robj *o = listNodeValue(head);
+            incrRefCount(o);
+            listDelNode(ll, head);
+            if (o->refcount != 1) {
+                decrRefCount(o);
+            } else {
+                lazyReleaseObject(o);
+            }
+        }
+    }
+
+    ac->batched_iter = NULL;
+    freeBatchedObjectIterator(it);
+    return C_OK;
+}
+
+/* *
+ * SLOTSRESTORE-ASYNC-ACK $errno $message
+ * */
+void
+slotsrestoreAsyncAckCommand(client *c) {
+    if (slotsrestoreAsyncAckHandle(c) != C_OK) {
+        c->flags |= CLIENT_CLOSE_AFTER_REPLY;
+    }
+}
+
+extern int time_independent_strcmp(const char *a, const char *b);
+
+/* *
+ * SLOTSRESTORE-ASYNC-AUTH $passwd
+ * */
+void
+slotsrestoreAsyncAuthCommand(client *c) {
+    if (!server.requirepass) {
+        slotsrestoreReplyAck(c, -1, "Client sent AUTH, but no password is set");
+        return;
+    }
+    if (!time_independent_strcmp(c->argv[1]->ptr, server.requirepass)) {
+        c->authenticated = 1;
+        slotsrestoreReplyAck(c, 0, "OK");
+    } else {
+        c->authenticated = 0;
+        slotsrestoreReplyAck(c, -1, "invalid password");
+    }
+}
+
+/* *
+ * SLOTSRESTORE-ASYNC-SELECT $db
+ * */
+void
+slotsrestoreAsyncSelectCommand(client *c) {
+    long long db;
+    if (getLongLongFromObject(c->argv[1], &db) != C_OK ||
+            !(db >= 0 && db <= INT_MAX) || selectDb(c, db) != C_OK) {
+        slotsrestoreReplyAck(c, -1, "invalid DB index (%s)", c->argv[1]->ptr);
+    } else {
+        slotsrestoreReplyAck(c, 0, "OK");
+    }
+}
diff --git a/extern/redis-4.0.1/src/t_hash.c b/extern/redis-4.0.1/src/t_hash.c
index 700a6233..8bab614b 100644
--- a/extern/redis-4.0.1/src/t_hash.c
+++ b/extern/redis-4.0.1/src/t_hash.c
@@ -52,6 +52,14 @@ void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {
     }
 }
 
+/* Encode given objects in-place when the hash uses a dict. */
+void hashTypeTryObjectEncoding(robj *subject, robj **o1, robj **o2) {
+    if (subject->encoding == OBJ_ENCODING_HT) {
+        if (o1) *o1 = tryObjectEncoding(*o1);
+        if (o2) *o2 = tryObjectEncoding(*o2);
+    }
+}
+
 /* Get the value from a ziplist encoded hash, identified by field.
  * Returns -1 when the field cannot be found. */
 int hashTypeGetFromZiplist(robj *o, sds field,
-- 
2.11.0 (Apple Git-81)

