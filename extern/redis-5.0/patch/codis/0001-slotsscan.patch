diff --git a/extern/redis-5.0/src/server.c b/extern/redis-5.0/src/server.c
index f6e4d0a5..e94487a4 100644
--- a/extern/redis-5.0/src/server.c
+++ b/extern/redis-5.0/src/server.c
@@ -316,6 +316,7 @@ struct redisCommand redisCommandTable[] = {
     {"slotsrestore",slotsrestoreCommand,-4,"awm",0,NULL,1,1,1,0,0},
     {"slotsdel",slotsdelCommand,-2,"w",0,NULL,1,-1,1,0,0},
     {"slotscheck",slotscheckCommand,0,"r",0,NULL,0,0,0,0,0},
+    {"slotsscan",slotsscanCommand,-3,"rR",0,NULL,0,0,0,0,0},
     {"xadd",xaddCommand,-5,"wmFR",0,NULL,1,1,1,0,0},
     {"xrange",xrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
     {"xrevrange",xrevrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
@@ -2657,8 +2658,7 @@ int processCommand(client *c) {
     } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||
                (c->argc < -c->cmd->arity)) {
         flagTransaction(c);
-        addReplyErrorFormat(c,"wrong number of arguments for '%s' command",
-            c->cmd->name);
+        addReplyErrorFormat(c,ERRFMT_WRONG_ARGC,c->cmd->name);
         return C_OK;
     }
 
@@ -3007,8 +3007,7 @@ void authCommand(client *c) {
 void pingCommand(client *c) {
     /* The command takes zero or one arguments. */
     if (c->argc > 2) {
-        addReplyErrorFormat(c,"wrong number of arguments for '%s' command",
-            c->cmd->name);
+        addReplyErrorFormat(c,ERRFMT_WRONG_ARGC,c->cmd->name);
         return;
     }
 
diff --git a/extern/redis-5.0/src/server.h b/extern/redis-5.0/src/server.h
index ce4b406d..0475a60a 100644
--- a/extern/redis-5.0/src/server.h
+++ b/extern/redis-5.0/src/server.h
@@ -494,6 +494,9 @@ typedef long long ustime_t; /* microsecond time type. */
 #define REDISMODULE_AUX_BEFORE_RDB (1<<0)
 #define REDISMODULE_AUX_AFTER_RDB (1<<1)
 
+/* Error information format. */
+#define ERRFMT_WRONG_ARGC "wrong number of arguments for '%s' command"
+
 struct RedisModule;
 struct RedisModuleIO;
 struct RedisModuleDigest;
@@ -2156,6 +2159,7 @@ void slotsmgrttagoneCommand(client *c);
 void slotsrestoreCommand(client *c);
 void slotsdelCommand(client *c);
 void slotscheckCommand(client *c);
+void slotsscanCommand(client *c);
 void latencyCommand(client *c);
 void moduleCommand(client *c);
 void securityWarningCommand(client *c);
diff --git a/extern/redis-5.0/src/slots.c b/extern/redis-5.0/src/slots.c
index 4dd865bc..13c15aa0 100644
--- a/extern/redis-5.0/src/slots.c
+++ b/extern/redis-5.0/src/slots.c
@@ -8,6 +8,10 @@ static int parse_int(client *c, robj *obj, int *p) {
     if (getLongFromObjectOrReply(c, obj, &v, NULL) != C_OK) {
         return -1;
     }
+    if (v < INT_MIN || v > INT_MAX) {
+        addReplyError(c, "value is out of range");
+        return -1;
+    }
     *p = v;
     return 0;
 }
@@ -116,7 +120,7 @@ void slotsinfoCommand(client *c) {
         }
     }
     if (c->argc >= 4) {
-        addReplyErrorFormat(c, "wrong number of arguments for 'slotsinfo' command");
+        addReplyErrorFormat(c, ERRFMT_WRONG_ARGC, c->cmd->name);
         return;
     }
     int i;
@@ -615,7 +619,7 @@ static void slotsScanSdsKeyCallback(void *l, const dictEntry *de) {
  * */
 void slotsrestoreCommand(client *c) {
     if (c->argc < 4 || (c->argc - 1) % 3 != 0) {
-        addReplyErrorFormat(c, "wrong number of arguments for 'slotsrestore' command");
+        addReplyErrorFormat(c, ERRFMT_WRONG_ARGC, c->cmd->name);
         return;
     }
     int n = (c->argc - 1) / 3;
@@ -688,7 +692,7 @@ void slotsdelCommand(client *c) {
     int slots_slot[HASH_SLOTS_SIZE];
     int n = 0;
     if (c->argc <= 1) {
-        addReplyErrorFormat(c, "wrong number of arguments for 'slotsdel' command");
+        addReplyErrorFormat(c, ERRFMT_WRONG_ARGC, c->cmd->name);
         return;
     }
     int i;
@@ -827,3 +831,64 @@ void slotscheckCommand(client *c) {
     }
     addReply(c, shared.ok);
 }
+
+/* *
+ * Usage: SlotsScan $slot $cursor [COUNT $count]
+ *
+ * Iterate the set of keys which in the currently selected db's specified slot.
+ * */
+void slotsscanCommand(client *c) {
+    int slot;
+    if (parse_slot(c, c->argv[1], &slot) != 0) {
+        return;
+    }
+    unsigned long cursor;
+    if (parseScanCursorOrReply(c, c->argv[2], &cursor) == C_ERR) {
+        return;
+    }
+    unsigned long count = 10;
+    if (c->argc != 3 && c->argc != 5) {
+        addReplyErrorFormat(c, ERRFMT_WRONG_ARGC, c->cmd->name);
+        return;
+    }
+    if (c->argc == 5) {
+        if (strcasecmp(c->argv[3]->ptr, "count") != 0) {
+            addReply(c, shared.syntaxerr);
+            return;
+        }
+        int v;
+        if (parse_int(c, c->argv[4], &v) != 0) {
+            return;
+        }
+        if (v < 1) {
+            addReply(c, shared.syntaxerr);
+            return;
+        }
+        count = v;
+    }
+    dict *d = c->db->hash_slots[slot];
+    list *l = listCreate();
+    listSetFreeMethod(l, decrRefCountVoid);
+
+    long loops = count * 10;
+    do {
+        cursor = dictScan(d, cursor, slotsScanSdsKeyCallback, NULL, l);
+        loops --;
+    } while (cursor != 0 && loops > 0 && listLength(l) < count);
+
+    addReplyMultiBulkLen(c, 2);
+    addReplyBulkLongLong(c, cursor);
+
+    addReplyMultiBulkLen(c, listLength(l));
+    while (1) {
+        listNode *head = listFirst(l);
+        if (head == NULL) {
+            break;
+        }
+        robj *key = listNodeValue(head);
+        addReplyBulk(c, key);
+        listDelNode(l, head);
+    }
+
+    listRelease(l);
+}
diff --git a/extern/redis-5.0/tests/unit/codis.tcl b/extern/redis-5.0/tests/unit/codis.tcl
index 2c7bc3b4..4a70a2ec 100644
--- a/extern/redis-5.0/tests/unit/codis.tcl
+++ b/extern/redis-5.0/tests/unit/codis.tcl
@@ -95,4 +95,69 @@ start_server {tags {"codis"}} {
         r flushdb
         r slotscheck
     } {OK}
+
+    # verify if slotsscan can iterate all the keys from the right slot
+    proc verify_slotsscan {slot pattern len {count "None"}} {
+        # iterate all the keys from the given slot
+        set cursor 0
+        set round 0
+        set keys {}
+        while 1 {
+            incr round
+            if {[string compare $count "None"] == 0} {
+                set res [r slotsscan $slot $cursor]
+            } else {
+                set res [r slotsscan $slot $cursor COUNT $count]
+            }
+            set cursor [lindex $res 0]
+            set tmp [lindex $res 1]
+            lappend keys {*}$tmp
+            if {$cursor == 0} break
+        }
+
+        # verify if all the keys in the given slot have been iterated
+        set keys [lsort -unique $keys]
+        assert_equal $len [llength $keys]
+        # verify if the key name match the pattern
+        foreach k $keys {
+            assert_match $pattern $k
+        }
+
+        return $round
+    }
+
+    test "SLOTSSCAN only iterate the set of keys which in the right slot" {
+        # init the env
+        r flushall;  # avoid the influence of the last case
+        set len0 16
+        set len1 32
+        set len2 48
+        r debug populate $len0 "{6qYGdH}";  # add some tagged keys into slot0
+        r debug populate $len1 "{2J8mrF}";  # add some tagged keys into slot1
+        r debug populate $len2 "{1yoSmd}";  # add some tagged keys into slot2
+        assert_equal {{0 16} {1 32} {2 48}} [r slotsinfo]
+
+        # test slotsscan with invalid argc
+        catch {r slotsscan 0} e
+        assert_match {*ERR*wrong*number*of*arguments*} $e
+        catch {r slotsscan 0 0 0} e
+        assert_match {*ERR*wrong*number*of*arguments*} $e
+        catch {r slotsscan 0 0 0 0 0} e
+        assert_match {*ERR*wrong*number*of*arguments*} $e
+
+        # test slotsscan without count option
+        verify_slotsscan 0 "*6qYGdH*" $len0
+        verify_slotsscan 1 "*2J8mrF*" $len1
+
+        # test slotsscan with normal count option
+        set round1 [verify_slotsscan 2 "*1yoSmd*" $len2 10]
+        set round2 [verify_slotsscan 2 "*1yoSmd*" $len2 20]
+        assert {$round2 < $round1}
+
+        # test slotsscan with invalid count option
+        catch {r slotsscan 2 0 count -1} e
+        assert_match {*ERR*syntax*} $e
+        catch {r slotsscan 2 0 count a} e
+        assert_match {*ERR*not*an*integer*} $e
+    }
 }
